# 유지보수 편하게 게임 서버 만들기

<pre>
* 시작전 주의
-> 최적화를 고려 하지 않은 기법 소개를 한다.
-> 많은 경우 퍼포먼스와 좋은 코드와 유지보수가 편한 코드는 서로 Trade-Off 관계이다.(그렇지 않은 경우도 존재)
-> 서버가 안정적이고, 더 빠르게 개발하는 것이 도움이 될 경우가 많다고 생각하여 관련 강의를 시작하였다.
</pre>

## 유지보수 편하게 게임 서버 만드는 기법

### 1. 작은 Type을 사용하지 마라.
<pre>
-> 여기서의 작은 Type은 char(int8_t) short(int16_t) 등을 이야기 한다.
-> 지금은 short면 충분하다고 생각했던 데이터들일지라도 게임 서비스가 길어지면서 값에 인플레가 진행되어 Type을 변경해야 하는 경우가
   자주 생긴다.
-> 최종 결과물은 short 범위에 들어갈 지 몰라도, 결과를 계산하는 중간에는 int64_t 범위가 필요할 경우도 있다.
-> int32_t, int64_t 외의 type은 사용하지 않는게 좋다.
-> 가능하면 int32_t도 사용하지 않는 것이 좋다.
    -> 게임업계에서도 C++ embedded script 유명한 lua가 이런식이다. 
</pre>

### 2. Unsigned를 사용하지 마라.
<pre>
-> Unsigned의 경우 사용 가능한 값 양수 범위가 고작 2배정도 늘어날 뿐이다.
    -> 게임 컨텐츠의 변경에 대응하기에 2배 정도의 증가로는 금새 같은 이슈에 직면하게 된다.
    -> 작은 Type을 사용하지 말라는 것과 같은 이유
-> 오류를 발견하는 것이 늦어질 가능성이 높다.
    -> 디버깅중, 절대 음수가 될 수 없는 값이 Overflow에 의해 음수가 될 경우 쉽게 눈치챌 수 있다.
-> 기획상 절대 음수가 될 수 없다고 생각했던 값에 음수가 들어가도록 바뀔 수도 있다.
-> Admin Tool, 게임 사이트 정보
    -> 요즘은 Web으로 만드는 것이 대세
    -> Web으로 만들 경우 다양한 언어를 쓸 수 있다.
        -> 한국에서 Web 개발시, Java의 점유율은 매우 높다.
        -> 하지만 Java는 Unsigned를 제공하지 않는다.
        -> Unsigned를 사용할 경우 같은 언어마다 Type이 달라지는 문제가 발생할 수 있다.
-> 빅데이터 분석의 경우
    -> 데이터 분석시 Spark를 자주 사용
    -> Spark에서는 언어로 Scala를 사용한다.
    -> Scala 역시 Unsigned를 지원하지 않는다.
-> Database 이슈
    -> 게임 역시 다양한 DB를 사용할 수 있다.
        -> 한국에서 게임DB로 MSSQL의 점유율은 높은 편이다.
        -> MSSQL과 Postgresql의 경우 Unsigned를 지원하지 않는다.
        -> 단순한 Read & Write는 가능
            -> overflow가 발생한 채로 DB에 저장된다.
        -> 그 데이터를 쿼리 내에서 비교하거나, 통계용 데이터로 사용하면 문제가 생긴다.
    -> 실제 사례
        -> 서버에서 ID를 발급하고, 쿼리를 이용해 주기적으로 오래된 데이터를 지우는 프로세스가 있다.
            -> DELETE TOP 100 FROM TABLE ORDER BY VALUE
            -> 서비스가 오래된 후, ID가 int 범위를 넘어설 정도로 발급되자 DB에 음수로 저장되어 최신의 데이터가 계속 삭제되는 장애 발생
</pre>

### 3. 변수를 Bit 단위로 쪼개서 사용하지마라.
<pre>
-> 디버거나, 로그에서 값을 알아보기가 굉장히 힘들어진다.
-> 값을 합치고, 다시 분해할 때 실수의 여지가 많다.
-> 각각의 값을 나타내는 범위가 좁아져서 기획 변경에 의한 쇼크가 크게 다가온다.
-> 본해된 값과 원본 각각의 값을 서로 잘못 대입하여 데이터를 날리는 실수를 할 가능성이 높다.
-> 그냥 변수 여러개 들어있는 구조체 선언해서 사용하는 것이 좋다.
-> 실제사례
    -> int32_t를 각각 8bit / 24bit로 쪼개서 서버ID/ 캐릭터 ID로 사용하였으나, 256개 이상의 서버를 오픈하게 되자 데이터가 오염되어 장애발생 
</pre>

### 4. Bit Flag를 사용하지 마라.
<pre>
-> 디버거나, 로그에서 값을 알아보기가 굉장히 힘들어진다.
-> 비트연산의 경우 익숙하지 않으면 실수의 여지가 많다.
-> 서비스가 오래되면 int32_t로는 부족한 경우가 많이 생긴다.
    -> 실제로 이 이슈 때문에 코드 갈아엎다가 실수하여 장애가 발생하는 경우를 많이 경험하였다.
-> int64_t의 경우 bit 연산이 불가능한 언어들이 존재한다.
    -> Javascript(node.js)의 경우 int32_t 까지만 bit연산이 가능하다.
-> 메모리에선 std::set이나 std:vector를 사용하고, DB에는 varbinary 등의 가변 길이로 저장하는 것이 좋다.
    -> 최신의 DB를 사용할 경우 Json Query를 사용할 수도 있다.
</pre>

### 5. ID는 int64나 string으로 해라.
<pre>
-> 많은 경우 ID를 int32_t로 발급하는데 이 경우 서비스가 커질 경우 문제가 발생 할 여지가 있다.
-> 특히 무난히 서비스 하다가 중국 서비스 시에 문제가 생기는 경우가 많다.
-> 실제 사례
    -> NPC ID를 int32_t로 발급
    -> 한번 클리어 하는데 5분정도 걸리는 보상이 괜찮은 이벤트용 던전 오픈
    -> 이벤트용 던전에 멋진 연출을 위한 수만마리의 NPC 배치
    -> 봇들이 해당 던전을 미친듯이 클리어
    -> int32_t 범위를 넘어서며 상시 살아있는 상점 NPC등과 같은 ID가 재발급되어 장애 발생
</pre>
## 6. Table의 PK는 Global Unique하게 만들어라.
<pre>
-> 게임 서비스가 오래되면 반드시 발생하는 이슈가 셋 있다.
    -> 서버통합
    -> 서버이전
    -> 통합서버
-> 많은 게임의 경우 서버이전과 서버통합을 지원하기 위해 툴이나 쿼리등에 많은 노력을 투자한다.
    -> 하지만, PK가 Global Unique할 경우 단순히 테이블 전체를 Select -> Insert 하는 것 만으로도 간단히 서버통합이 종료된다.
-> 게임 기획상 문제가 없다면 캐릭터 명, 길드 명 등도 Unique 하면 좋다.
    -> 통합서버 등에서 귓말기능 등을 지원하기가 굉장히 편해진다.
    -> 배틀넷의 배틀태크, B&S의 캐릭터명 등이 이런 케이스
-> 통합서버를 지원하기 위해 같은 ID를 가지는 캐릭터를 처리하기 위해 내부 구조를 크게 바꾸는 경우가 많다.
-> 하지만 ID가 Global Unique할 경우 변경이 최소화 된다.
</pre>

### 7. 패킷 구조와 관련 코드는 자동생성 하라.
<pre>
-> 설마 아직도 패킷을 Buffer에 한땀한땀 Write 해 가며 조립을 하는 게임 서버 개발자는 없을 것이다.
    -> 추가적인 시간을 투자하기 힘들다면 google protobuf 등의 이미 안정성이 검증된 라이브러리를 사용하는 것을 추천한다.
-> 패킷을 자동생성하면 Client / Server 양쪽에서 같은 작업을 반복해야하는 이슈가 생기지 않는다.
    -> 많은 팀에서 서버프로그래머가 네트워크에 문외한인 클라이언트 프로그래머를 대신해 패킷 관련 처리를 독박쓴느 것을 볼 수 있다.
-> 실수의 여지가 적다.
    -> 같은 패킷을 서로 다르게 해석하여 생기는 문제가 발생하지 않는다.
-> 추가적인 용량 최적화가 편해진다.
-> 추가적인 용량 최적화의 예제 패킷
    -> enum class CharacterClass {
           MAGE = 0,
           PRIEST = 1,
           TANKER = 2,
           ARCHER = 3,
    };
      enum class StorageExtendLevel {
           NO_EXTEND = 0,
           EXTEND_1 = 1,
           EXTEND_2 = 2,
           CASH_PAID_EXTEND = 3,
    };
      struct MyPacket {
           int64_t userId = 10000;
           int64_t accountId = 10000;
           bool isAdmin = false;
           int64_t lastLoginTime;
           bool isReturningUser = true;
           int64_t guildId = 100;
           CharacterClass characterClass = CharacterClass::ARCHER;
           StorageExtendLevel storageExtendLevel = StorageExtendLevel::CASG_PAID_EXTEND;
           int64_t gold = 1000000;
    };
    -> 단순히 계산하면 50Byte의 Size를 가지는 패킷이다.
    -> 이것을 용량 관련하여 최적화를 해보자.
    -> int64 나 enum (default 크기는 int32_t)의 범위를 전부 다 사용하는 경우는 다물다.
        -> 대부분의 경우 해당 범위의 일부분을 사용하고, 가끔씩 범위를 넘어가는 값이 있는 정도이다.
        -> 현재 이 패킷에서 userId, accountId는 2byte 범위에서 표현 가능하고, guild는 1byte 범위에서, gold는 4byte로 표현 가능하다는 것을 알 수 있다.
    -> CharacterClass Enum과, StorageExtendLevel Enum은 범위가 0~3dlamfh 2bit로 표현이 가능하다.
       2개의 bool 값인 isAdmin, isReturningUser는 당연히 1bit로 표현이 가능하다.
    -> 별도의 Table header을 만드는 방식으로 해당 패킷을 최적화 해보자
        -> 정수형의 경우 2bit를 이용해 각각 실제로 점유하는 크기를 표현한다.
            -> 00: 1byte (int8_t)
            -> 01: 2byte (int16_t)
            -> 10: 4byte (int32_t)
            -> 11: 8byte (int64_t)
        -> Enum의 경우 최대값을 기준으로 bit를 할당한다.
            -> 둘다 0~3의 값을 가지니 2bit를 할당
        -> Bool의 경우는 1bit로 할당한다.
        -> 그럼 아까의 구조체의 경우 아래와 같은 2Byte의 Table을 가지게 된다.
        -> 이후 int64_t의 값을 지정한 만큼의 크기로 Buffer에 쓰면
            -> 각각 2Byte + 2Byte + 1Byte + 1Byte + 4Byte = 10Byte
               Table과 합쳐서 12Byte 만으로 필요한 정보를 모두 보낼 수 있다.
    -> 간단한 예를 소개했지만, 이중 일부는 protobuf 등에도 이미 적용되어 있는 방식이다.
    -> protobuf의 경우 기본값을 가지는 데이터는 아예 0byte를 할당 하는 식의 최적화도 제공하고 있다.
    -> 게임 구조나 특성에 맞춰 패킷 룰을 잘 만들경우, 큰 Type을 씀으로서 생기는 packet 크기 이슈를 수동으로 패킷을 만드는 것보다
       훨씬 간단하게 사용하면서도 강력하게 packet 크기를 줄일 수 있다.
</pre>

## 8. Multi Phase Static Data Loading (데이터를 여러 페이지로 쪼개서 로딩하라)
<pre>
-> 게임서버는 서버 SW 중에서도 굉장히 특이한 특징을 하나 가지고 있다.
-> 서버를 구동하기 위해 필수적인 정적 데이터가 수백MB ~ 수십GB가 로딩되어야 한다는 것이다.
    -> 그리고 이 데이터 로딩 시간은 게임 개발/테스트에 큰 장애물이다.
-> 그리고 많은 경우 데이터는 Table 형태이며, 다른 Table을 참조하여 Join을 하여야 한다.
-> 하지만, 많은 경우 단순히 아래의 순서로 데이터를 로딩하는 경우가 많다.
    -> 파일 로딩
    -> 로딩된 데이터를 객체로 변경
    -> 객체생성후 이미로딩된 다른 객체를 참조한다.
-> 위와 같은 식으로 데이터를 로딩할 경우 데이터 로딩순서에 크게 의존하게 되고, MultiCore를 활용하는 것이 매우 어렵다.
-> 다음과 같이 Phase를 나눠서 데이터를 로딩 하는것을 추천한다.
    -> Raw Data Load Phase : 데이터를 로딩하여 객체로만 만든다.
    -> Relation Phase : 객체간의 연관 관계를 이어주는 작업을 한다.
    -> Additional Phase : 만약 필요하다면 추가적인 작업을 한다.
-> 하나의 Phase 안에서는 서로 독립적으로 작업한다.
-> 다음 Phase로 넘어가면 기존 Phase의 데이터는 Readonly 상태이다.
-> 위의 룰을 지킨다면 CPU의 Core를 최대한 활용하여 빠르게 데이터를 로딩할 수 있다.
</pre>

### 9. Date, Time 관련 함수를 사용하지 마라.
<pre>
-> 시간 관련 함수 / 객체는 아래와 같은 것들이 있다.
    -> ex) std::time, std::localtime, GetTickCount / GetTickCount64, GetSystemTime, GetLocalTime, ...
-> 해당함수들을 사용하게 되면 실제 시간(RealTime)에 의존하게 된다.
-> 하지만 게임을 개발/서비스 하는 중에는 다양한 이슈들이 발생한다.
-> 특정 시간에만 작동하는 이벤트 등을 개발/테스트 해야 하는 경우
    -> 크리스마스 등의 이벤트를 개발하거나, 해외용 컨텐츠를 개발해야 할 경우 흔하게 발생하는 케이스이다.
       이 경우 TimeZone 과 현재 시간/날짜 등을 자유롭게 변경할 수 있다면 테스트가 매우 수월 해 진다.
-> 자동화 테스트를 진행해야 할 경우
    -> 게임 컨텐츠를 자동으로 테스트 할 때, 일반적인 스피드로 테스트를 하면 지나치게 오래 걸리는 경우가 많다.
    -> 게임의 Speed를 자유롭게 조정할 수 있다면, 시간이 오래 걸리는 컨텐츠 테스트를 빠르게 할 수 있다.
        -> ex) Unity 엔진의 Time.timeScale 세팅과 비슷한 방식
-> 위와 같은 이유로, 게임에서 사용하는 시간/날짜 관련 함수는 직접 호출을 금지하고
   게임 내부에서 가상의 시간을 제공하는 함수를 별도로 제공하는 것이 좋다.
</pre>
### 10. boost library 쓰지 마라.
<pre>
-> Classic C++(~C++03) 까지는 C++ 기본 라이브러리의 기능이 극히 부족하였다.
   그래서 모자라는 표준 라이브러리를 보충하기 위해 boost를 사용하는 경우가 많았다.
   하지만, Modern C++(C++ 11 이후. 현재 최신은 C++ 20) 에는 boost에서 자주 쓰이는 기능은 대부분 표준에 포함되어 있다.
-> 그 외, boost에서 제공하는 각종 유틸리티 라이브러리(ssl, http, json, xml, etc..) 완성도가 낮거나,
   성능이 낮거나, 기능이 별로 좋지 않은 것들이 대부분이다.
-> boost는 각 library 간 의존성이 매우 강한편이고, 디버깅이 매우 어렵고, 컴파일이 매우 느리다, 용량도 크다..
-> 대부분의 경우 boost를 제거하고, 비슷한 기능을 제공하는 다른 라이브러리로 교체하는 것만으로도
   C++의 개발의 가장 큰 병목인 컴파일 속도를 향상시킬 수 있다.
</pre>

### 11. C++로 통일하는 것에 집착하지 마라.
<pre>
-> 게임 업계는 C++이 메이저한 언어로 쓰이는 몇 안되는 분야중 하나
    -> 요즘 C++ 프로그래머를 찾으면 100명 중 99명은 Embedded나 Game 출신이다.
-> 현실적으로 C++은 범용 프로그래밍 언어로서의 지위는 잃었고 Domain-Specific Language에 가깝다.
    -> 덕분에 C++로 하기가 극단적으로 불편해진 파트가 몇 있다.
-> Cache, DB Query, 3rd Party나 Publicher 와의 http 연동 등을 담당하는 서버를, 해당 작업이 편한 다른 언어로 만들어 띄우면 
   작업 효율이 매우 좋아진다.
    -> C++ SDK를 제공하지 않는 업체도 많다.
    -> 물론 해당 언어의 개발 환경을 잘 이해하고 있다는 전제는 필요하다.
    -> 전혀 모르는 상태에서 진행하여 C# 이나 Python 등을 마치 C++ 처럼 사용하여 필요하지 않은 코드를 작성하게 되어
       효율을 얻지 못하는 경우가 있다.
       ex) C#으로 된 서버에 DB Connection Pool을 직접 구현 한 경우
</pre>

### 12. 빌드 속도 향상에 신경써라
<pre>
-> C++은 현존하는 메이저 언어중 가장 느려터진 빌드 속도를 자랑한다.
    -> 게임 개발 시간중, 빌드에 낭비하는 시간이 그야말로 엄청나다.
-> 덕분에 C++은 분산 빌드 도구가 잘 갖춰진 언어가 되어 있따.
    -> 이것을 활용하지 않는 것은 굉장한 낭비이다.
       ex) Windows : IncrediBuild, Linux : distcc
-> Source 파일 여러개를 Core 수 만큼으로 묶어서 컴파일 개수를 줄이는 Unity Build라는 기법도 존재한다. 상황에 맞게 적용해야 한다.
-> 가능하면 서버를 여러개의 라이브러리로 쪼개서, 코드의 일부를 수정하였을 때 최대한 영향 받는 파일을 줄이는 것이 좋다.
    -> 최신의 컴파일러를 사용한다면 C++ Module을 사용하는 것도 고려 해보자
-> Unreal 4 엔진 등은 이미 모듈, Unity Build와 분산 빌드 모두를 지원하여 빌드 속도를 최대한 끌어올리고 있다.
   서버 프로그래머라도 Unreal 4의 빌드 시스템을 한번 구경정도는 해보자
</pre>

<pre>
출처 : C++ Korea 제9회 세미나 관련자료
ref : https://youtu.be/NiDbkG_Eqpo 
</pre>
</pre>
