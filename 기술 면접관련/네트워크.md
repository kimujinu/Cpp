# 네트워크 

<pre>
1. HTTP란 무엇인가요?
-> HyperText Transfer Protocol의 약자로 WWW(World-wide-web)에 내재된 프로토콜이다.
-> WWW에서 하이퍼텍스트 문서를 교환하기 위하여 사용되는 통신 규약으로 초기에 사용했던 HTTP 프로토콜은 매우 단순하였다.
    -> 이를 HTTP/0.9버전이자 단일 프로토콜(One-line)이라고 하며, 많은 개선을 거쳐 현재의 표준화된 HTTP/1.1, 더 나아가 HTTP/2.0이 등장하게 된다.
    -> HTTP/0.9-원-라인 프로토콜
        -> HTTP 프로토타입이다. 초기버전
        -> HTTP/0.9는 극도로 단순하여 많은 구조적 결함과 문제가 있었다.
        -> 요청은 GET 메서드와 요청 URL만으로 구성된다.
        -> 응답은 시작줄, 헤더 없이 오직 엔티티 분문만이 존재한다.
        -> 위의 이유로 HTML 파일만 전송이 가능했다.
        -> 상태 코드가 존재하지 않아 파일 내부에 상태에 대한 설명을 첨부하여 응답하였다.
    -> HTTP/1.0-확장성 추가
        -> 매우 제한적이었지만, 브라우저와 서버 모두 빠르게 확장되기 시작한다.
        -> 버전 번호가 추가되었다.
        -> HTTP 헤더와 메서드가 추가되었다.
        -> 멀티미디어 객체 처리가 추가되었다.
        -> 시각적인 효과를 가진 폼을 구현하여 WWW를 대세로 만들었다.
        -> Keep-alive 커넥션이 추가되었다.
        -> 가상 호스팅을 지원하게 되었다.
        -> 프록시 연결을 지원한다.
    -> HTTP/1.1-현재의 표준 프로토콜
        -> 구현과 표준화를 동시에 진행했던 HTTP/1.0의 개선된 버전이다.
        -> 커넥션의 재사용이 가능해졌다.
            -> 기존에 응답받은 리소스를 시간을 절약하면서 출력할 수 있게 되었다.
        -> 파이프라이닝이 추가되었다.
            -> 첫 요청이 도달만 한다면 요청에 대한 응답이 도달하지 않아도 두 번째 요청이 할 수 있게 되었다.
               이는 커넥션의 시간을 단축한다.
        -> 청크된 응답을 지원한다.
        -> 캐시 제어 메커니즘이 도입되었다.
        -> 컨텐츠 협상이 도입되었다.
            -> 브라우저-서버가 교환하려는 컨텐츠(언어, 인코딩 등)가 적합한지 판단할 수 있게 되었다.
        -> Host 헤더가 도입되었다.
            -> 동일 IP 주소에 다른 도메인을 호스트할 수 있는 코로케이션이 가능하다.
                -> 코로케이션(Colocation) : 자신의 서버를 직접 인터넷 데이터 센터(IDC)로 운반하여, 미리 준비된 공간에 서버를 입고시킨 후 사용하는 방식이다.
    -> HTTP/2.0-더 나은 성능을 위한 프로토콜
        -> 구글의 SPDY 프로토콜을 적용했고, HTTP/1.0의 문제를 개선한 아직 표준화되지 않은 초안이다.
        -> SPDY 프로토콜의 특징
            -> 이진 프로토콜에 가까운 형태이다.
                -> 읽거나 작성할 수 없으므로, 새로운 최적화 기술이 구현될 수 있다.
            -> 병렬 요청이 동일한 커넥션에서 이루어질 수 있는 다중화 프로토콜
                -> HTTP/1.1이 지닌 제약사항인 순서를 제거했다.
            -> 전송된 데이터의 중복을 제거한다.
                -> 이러한 데이터로부터 유발되는 오버헤드를 해소하고 연속된 요청의 유사한 헤더를 압출할 수 있다.
            -> 서버 푸시라는 메커니즘을 도입하였다.
                -> 클라이언트 캐시에 필요한 데이터를 전송할 수 있게 되었다.
                
2. HTTP/1.1과 HTTP/2.0의 차이점은 무엇인가?
-> HTTP/1.1의 가장 큰 문제점, 회전 지연(Latency)를 해결하기 위해 제안되었다.
-> HTTP/1.1의 요청-응답 메시지 포맷은 구현의 단순성, 접근성을 중점으로 최적화되었다. 
   하나의 요청에 하나의 응답만을 받는(1:1) HTTP 메시지 교환 방식은 
   응답을 받아야만 다음 요청을 보낼 수 있으므로 심각한 회전 지연이 발생하였다.
	 병렬 커넥션, 파이프라인 커넥션 등이 도입 되었지만 이를 완전 해결하진 못했다.
-> HTTP/2.0은 기존의 요청-응답과는 약간 다른 서버 푸시(Server Push)를 도입, 요청을 명시적으로 받지 않아도 능동적으로 클라이언트에 리소스를 전송할 수 
	 있게 되었다.
차이점:
-> HTTP/2.0의 모든 메시지는 프레임에 담겨 전송된다.
-> 스트림(Stream)과 멀티 플렉싱(Multi-flexing)을 지원한다.
    -> 하나의 커넥션에 여러 스트림이 동시에 열리거나 우선순위를 가질수 있다.
-> 헤더 압축을 압축하여 보내므로 중복된 내용을 효과적으로 처리 할수 있다.
-> 서버 푸시가 도입되어 클라이언트가 능동적으로 리소스를 푸시한다.
-> 효율적인 페이지 로딩을 위해 URL 이미지, 스크립트 등의 리소스를 압축하여 요청을 감소시킨다.

3. HTTP 메시지란 무엇인가요?
-> HTTP 애플리케이션 간에 주고받은 메시지의 블록들이다.
-> 데이터 블록은 메시지 내용과 의미를 설명하는 텍스트 메타 정보로 시작한다.
   그 다음에는 선택적으로 데이터가 존재할 수 있다. 
   이런 메시지는 클라이언트(브라우저), 서버, 프록시 사이를 흐르며, 흐르는 방향을 인바운드, 아웃바운드, 업스트림, 다운스트림이라고 한다.
-> 메시지는 아주 단순하다.
   클라이언트로부터의 요청이나 서버로부터의 응답 중 하나를 포함하며, 시작줄, 헤더 블록, 본문의 세 항목으로 나누어진다.

4. HTTP 메서드의 종류에는 무엇이 있나요?
-> 모든 서버가 HTTP 메서드를 구현하지는 않음을 유의하여야 한다.
-> HTTP 메서드는 대부분 제한적으로 사용되며 서버마다 다르게 결정되기도 한다.
   기본적으로 정의된 메서드를 사용하기도, 확장하기도, 변형하기도 한다.
기본적인 메서드의 종류
-> GET : 리소스 취득, 서버에서 특정 문서를 가져온다.
-> HEAD : 메시지 헤더 취득, 서버에서 특정 문서에 대한 헤더만 가져온다. 
-> POST : 엔티티 바디 전송, 서버가 처리할 데이터를 전송한다.
-> PUT : 리소스 전송, 서버에 요청 메시지 본문을 저장한다.
-> TRACE : 경로 조사, 보낸 메시지를 다시 돌려받는다.
-> OPTIONS : 서포트 메소드 문의, 요청한 URL에 어떠한 메소드 요청이 가능한지 묻는다.
-> DELETE : 리소스 삭제, URL의 리소스를 삭제한다.

5. HTTP 상태 코드의 종류는 무엇이 있는가?
-> 100 : continue, 요청의 시작 일부가 허용되었으니, 클라이언트는 나머지를 계속 요청하라는 의미
-> 101 : Switching Protocols, 클라이언트가 Upgrade 헤더에 나열한 것 중 하나로 서버가 프로토콜을 변경했다는 의미
-> 200 : OK, 요청이 정상이며 엔티티 본문이 요청된 리소스를 포함하고 있다.
-> 202 : Accepted, 요청은 허용되었으나 서버는 어떤 동작도 수행하지 않았음
-> 300 : Multiple Choices, 클라이언트가 여러 리소스를 가리키는 URL을 요청하면 그 리소스의 목록과 함께 반환한다.
-> 301 : Accepted, 요청한 URL이 이동되었을 때 사용하며, Location 헤더에 URL을 포함해야 한다.
-> 401 : Unauthorzied, 클라이언틔 인증(유효한 사용자 ID와 암호)을 요구한다.
-> 403 : Forbidden, 요청이 서버에 의해 거부되었음을 의미한다.
-> 404 : Not Found, 서버가 요청한 URL을 찾을 수 없다.
-> 500 : Internal Server Error, 서버가 요청을 처리하지 못하게 만드는 에러가 발생한다.
-> 502 : Bad Gateway, 요청-응답 연쇄의 다음 링크로부터 에러가 발생했다.
-> 503 : Service Unavailable, 현재는 서버가 요청을 처리할 수 없으나 나중에는 가능함을 의미

6. 서버로 요청하면 일어나는 일련의 과정을 설명하라.
절차
-> 브라우저에 URL 입력
-> 호스트 명 획득
-> DNS 서버에 IP주소를 요청한다.
-> 어느 포트로 갈지 포트(Port)번호를 가져온다.
-> IP주소로 포트 번호에 연결한다.(Connection)
    -> 여기에서 3-Hand-Shaking이 일어난다.
-> 클라이언트가 HTTP 메서드를 통하여 서버에 요청한다.
-> 서버가 HTTP 상태, 코드로 클라이언트에 응답한다.
-> 커넥션 종료.

자세한 과정
-> 기본 정보를 확인한다.
    -> 브라우저의 로컬 Hosts 파일에 입력한 URL에 연결된 정보가 있는지 확인한다.
-> 외부와 통신할 준비를 한다.
    -> DHCP(Dynamic Host Configuration Protocol)에서 브라우저의 IP주소, 가장 가까운 라우터(Router)의 IP주소,
       가장 가까운 DNS 서버의 IP주소를 수신한다.
    -> 주소 결정 프로토콜(Address Resoltion Protocol, ARP)로 이동하려는 URL 호스트에 연결된 IP주소와 가장 가까운 라우터의 MAC주소를 확인한다.
-> DNS 서버와 IP주소를 송수신한다.
    -> DNS Query를 DNS 서버에 송신하면 DNS 서버는 쉡 서버의 IP주소를 브라우저로 반환한다.
-> 웹 서버에 접속(연결)한다.
    -> 요청을 위해 TCP 소켓을 개방한 뒤 연결한다.
       이 과정에서 3-Hand-Shaking이 일어나며, TCP 연결이 성공되면 요청이 소켓을 통해 전송된다.
-> 서버는 요청을 처리하여 클라이언트에게 응답하며, 커넥션을 종료한다.
-> 응답된 전송을 브라우저가 수신한다.

7. HTTP와 HTTPS의 차이점은 무엇인가?
HTTP의 개요
-> 인터넷상에서 데이터를 주고 받기 위한 서버/클라이언트 모델을 따르는 전송 프로토콜이자 애플리케이션 레벨의 프로토콜로 TCP/IP위에서 작동한다.
-> 상태를 가지고 있지 않은 Stateless 프로토콜이다.
    -> Method, Path, Version, Headers, Body 등으로 구성된다.
-> 비상태연결(Stateless, Connectless)
    -> 서버에 연결하고 요청해서 응답을 받으면 연결을 끊는다.
    -> 장점
        -> 접속유지 최소화
        -> 불특정 다수를 대상으로 하는 서비스에 유리
    -> 단점
        -> 연결을 끊어버리므로 클라이언트의 이전 상태를 알 수 없다.
        -> 따라서 로그인을 해도 정보유지 불가
        -> 이를 해결하기위해 쿠키, 세션등을 이용한다.
HTTPS의 개요
-> HTTP 통신 소켓을 SSL(Secure Socket Layer)/TLS(Transport Layer Security) 프로토콜로 대체하였다.
    -> 즉, HTTP-SSL-TCP와 통신하는 시스템으로 암호화와 증명서, 안정성 보호를 이용할 수 있게 되었다.
    -> 공개키/개인키 암호화를 지원하여 데이터를 보호한다.
-> 평문 통신에 비해 암호화 통신은 CPU나 메모리가 많이 필요하여 민감한 정보를 다룰 때에만 사용한다.
    -> HTTP 2.0이 발전되면서 HTTPS가 HTTP보다 빠르다고 한다.
-> 기본적으로 443번 포트를 사용한다.

8. OSI 7계층을 설명해주세요.
OSI(Open System Interconnection Reference Model)의 개요
-> 컴퓨터 네트워크 프로토콜 디자인과 통신을 계층으로 나누어 설명한 것으로 OSI 7 계층 모형이라고 한다.

PDU(Protoccol Data Unit) : 프로토콜 데이터 단위
    -> 계층이 전달한 데이터에 붙이는 제어 정보이다.

OSI 7계층
-> 응용계층
    -> 역할 : 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행
    -> PDU : 메시지
    -> 프로토콜 : HTTP, SMTP, SNMP, FTMP, Telnet, SSH ...
-> 표현계층
    -> 역할 : 송신측과 수신측 사이에서 데이터의 형식(png, jpg)을 정한다. 받은 데이터를 코드변환, 구문 검색, 암호화, 압축을 통해 
              올바른 표준방식으로 변환해 준다.
    -> PDU : 메시지
    -> 프로토콜 : JPG, MPEG, SMB ...
-> 세션계층
    -> 역할 : 세션을 수립, 유지, 종료 등의 세션 관리를 위한 계층
    -> PDU : 메시지
    -> 프로토콜 : NetBIOS, TLS ...
-> 전송계층
    -> 역할 : 양 끝단(End to End)의 사용자들이 신뢰성있는 데이터를 주고 받을 수 있도록한다.
              헤드에는 세그먼트가 포함되며 주소 설정, 오류 및 흐름 제어, 다중화를 수행한다.
              데이터를 전송하는 방식을 지정하기 위한 계층
    -> PDU : 세그먼트
    -> 프로토콜 : TCP, UDP, ARP ...
    -> 관련 장비 : 게이트웨이, L4 스위치
-> 네트워크 계층
    -> 역할 : 패킷을 종단 노드(End Node)간에 안전하게 주고 받기 위한 계층
    -> PDU : 패킷
    -> 프로토콜 : IP, ICMP...
    -> 관련장비 : 라우터, L3 스위치
-> 데이터 링크 계층
    -> 역할 : 포인트 투 포인트(Point to Point)간 신뢰성 있는 전송을 보장한다.
              송수신 속도 차이를 해결하기 위한 흐름제어와 프레임 동기화 등의 역할을 한다.
    -> PDU : 프레임
    -> 프로토콜 : 이더넷, MAC, PPP, ATM, LAN ...
    -> 관련장비 : 랜카드, 브릿지, 스위치
-> 물리 계층
    -> 역할 : 실제 장치들을 연결하기 위해 필요한 전기적, 물리적 세부 사항들을 정의한다.
    -> PDU : 비트
    -> 프로토콜 : Modem, Cable, Fiber, RS-232C
    -> 관련장비 : 리피터, 허브 ...
    
9. TCP와 UDP의 차이점은 무엇인가?
-> TCP(Stateful, 상태유지)는 신뢰성이 있는 연결
   UCP(Stateless, 무상태)는 빠른 전송을 지향하는 프로토콜이다.
-> TCP는 내가 보낸 데이터가 확실히 상대방에게 전달 되었는지 포커를 맺고(ex) HTTP 통신, 이메일 파일 전송), UDP는 일방적으로 전송을 한다.
-> UDP의 한 예로 스트리밍 방송이 있는데, 방송을 하다가 중간에 신호가 끊어져도 다음으로 그냥 이어서 방송을 하는 것처럼 
   UDP는 일방적인 데이터 전송을 하는 반면에, TCP는 데이터 하나라도 놓치지 않고 완벽히 보내는 것이 목적이라 방향성이 완전히 다르다.
-> UDP는 알고리즘이 간단한 반면, TCP는 연결부터 끊는 과정까지 상대적으로 복잡하다.

10. TCP/IP 4계층은 무엇인가?
TCP/IP(Transmission Control Protocol/Internet Protocol)의 개요
-> 인터넷 통신의 기반이 되는 프로토콜로 이를 이용해 컴퓨터를 연결하는 체계를 이더넷(Ethernet)이라고 한다.
-> 응용계층
    -> OSI 7계층의 세션 계층, 표현 계층, 응용 계층에 해당하며 TCP/UDP 기반의 응용 프로그램을 구현할 때 사용한다.
    -> FTP, HTTP, SSH...
-> 전송계층
    -> OSI 7계층의 전송 계층에 해당하며 통신 노드 간의 연결을 제어하고, 신뢰성 있는 데이터 전송을 담당한다.
    -> TCP, UDP...
-> 인터넷 계층
    -> OSI 7계층의 네트워크 계층에 해당하며 통신 노드 간의 IP패킷을 전송하는 기능과 라우팅 기능을 담당한다.
    -> IP, ARP, RARP...
-> 네트워크 액세스 계층
    -> OSI 7계층의 물리계층과 데이터 링크 계층에 해당하며 물리적인 주소로 MAC을 사용한다.
    -> LAN, 패킷망...
    
11. TCP-3-way-hands-shaking에 대해 설명하라.
-> TCP는 장치들 사이에 논리적인 접속을 성립하기 위해 3-way-handshake를 사용한다.
-> 3-way-handshake는 TCP/IP 프로토콜을 이용해서 통신을 하는 응용프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해,
   상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다.
과정
-> 클라이언트는 서버에게 SYN 패킷을 보내 접속을 요청하여 보냄 상태로 전환한다.
-> 서버는 클라이언트로부터 SYN요청을 받고, 클라이언트에게 요청을 수락한다는 ACK와 SYN flag가 설정된 패킷을 발송하고,
   클라이언트가 ACK로 응답하기를 기다리며, 승인 받음 대기상태가 된다.
-> 클라이언트는 서버에게 ACK를 보내며 연결이 이루어지고 데이터 송/수신이 이루어지게 된다.
   이 때, 서버의 상태는 성립이 된다.

* 4-way-handshake는 세션을 종료하기 위해 수행되는 절차

12. DNS의 Round Robin 방식을 설명하라.
-> L4 스위치 같은 로드밸런싱 장비가 부담이 될 때, 저렴하고 간단하게 서버 분산을 구현하는 방법이다.
    -> 클라이언트 세션을 유지하며 처음 연결한 서버에 지속적으로 연결해주는 기능은 없다.
    -> 간단한 요청과 결과로만 이루어진 페이지들이라면 사용할 수 있다.
-> 서버가 A,B,C 3대가 있으면 첫 요청에 A, 다음엔 B, 다음에 C로 연결하고 이후엔 다시 A-B-C 절차를 반복한다.
-> RoundRobin이란? 대화형 시스템에서 사용되는 선점 스케줄링 방식
                   시간 할당량을 매 프로세스에 주고 할당된 시간 안에 완료되지 못한 프로세스는 
                   준비 큐의 맨 뒤에 배치되도록 하여 CPU를 독점하지 않고 공평하게 이용될 수 있게 한다.

13. Routing Table은 무엇인가?
-> 주소를 이용하여 목적지까지 메시지를 전달하는 방법을 결정하는 경로 선택과정
   이 과정을 능동적으로 수행하는 장치를 라우터(Rounter)라고 한다.
-> 경로 선택을 위한 데이터베이스(목록)을 라우팅 테이블(Routing Table)이라고 하며,
   목적지 네트워크 주소, 라우터의 출구 포트 정보, 최적 경로 산출을 위한 Metrics등의 정보를 포함한다.
    -> 라우터가 최적의 경로를 찾아 결정할 때 사용한다.
    -> 라우터가 패킷을 수신하면 패킷의 목적지 IP주소를 검사하고, 
       라우터의 라우팅 테이블안에 있는 가장 일치하는 네트워크 주소를 검색한다.
    -> 라우팅 테이블은 또한 패킷을 전송하는데 사용되는 인터페이스를 포함한다.
    -> 부합하는 네트워크를 찾게되면 라우터는 밖으로 나가는 인터페이스의 데이터링크 프레임 안에 IP 패킷을 캡슐화하고,
       그것의 목적지 쪽으로 패킷을 전송.

14. URL Encode는 무엇인가?
-> Encoding이란 정보의 형태, 형식을 내용의 변경 없이 변환하는 처리 방식
   암호화로는 사용할 수 없으며, ASCII, URL, Base64, MS Script 등이 있다.
-> 주소 지정을 목적으로 웹 브라우저/서버가 이해할 수 있는 문자로 특수 문자를 대체한다.

15. UTF-8을 설명하라.
-> 가장 많이 사용되는 가변 길이 유니코드 인코딩이다.
-> 표현 가능한 길이는 최대 6바이트이지만 다른 인코딩과의 호환을 위해 4바이트까지만 사용한다.
-> 아스키 코드의 0~127까지는 UTF-8로 완전히 동일하게 기록된다.
    -> 아스키로 구축된 사이트를 별다른 변환 처리 없이 그대로 쓸 수 있는 엄청난 장점이 있다.
-> UTF-8은 엔디안에 상관없이 똑같이 읽을 수 있으므로 크로스플랫폼 호환성도 뛰어난다.
    -> 엔디안(Endianess) : 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법
        -> 리틀 엔디안 : 최하위 바이트 부터 차례로 저장하는 방식
        -> 빅 엔디안 : 최상위 바이트부터 차례로 저장하는 방식
   
16. URL과 URI의 차이점을 설명하라.
-> URI는 식별하고 URL은 식별하는 찾는다.
-> URI의 하위개념으로 URL, URN이 있다.
    -> URL(Uniform Resource Locator) : 파일 식별자, 유일자원 지시기
    -> URN(Uniform Resouce Name) : 통합 자원 이름
  
17. Server의 인증방식에 대해 설명하라.
-> 인증이 필요한 이유
    -> 서버에서는 사용자가 보낸 요청을 받았을 때 그것이 누구의 요청인지 정확하게 알아야 한다.
        -> Front-end 관점 : 사용자의 로그인, 회원가입과 같이 사용자의 도입부분
        -> Server-side 관점 : 모든 API 요청에 대해 사용자를 확인하는 작업
-> 계정 정보를 Request Header에 넣는 방식을 사용
-> 세션(Session, 서버)과 쿠키(Cookie, 클라이언트)
    -> 무연결 프로토콜(Connectionless Protocol)의 불편함을 해결하기 위해 클라이언트-서버의 연결을 유지해주는 방법들이다.
    -> 웹 서비스는 클라이언트와 서버의 관계를 유지하지 않는 특성을 지닌 HTTP 프로토콜을 기반으로 한다.
        -> 서버의 부하가 최소화되나 기능 구현은 어렵다.
    -> 서버와 클라이언트의 연결 상태를 유지
        -> Connectionless Protocol의 불편함을 해결하기 위해서 세션과 쿠키를 이용한다.
	
18. IOCP의 목적과 정의에 대하여 설명하라.
-> 멀티스레드 윈속서버 프로그램의 경우 user한명당 Thread가 1개씩 할당이 된다.
   사용자수가 많아지면 Thread의 동적생성과 Thread간의 잦은 context switching으로 인한 overhead가 크게 증가한다.
   이러한 점을 극복하기 위해 IOCP가 만들어졌다.
   IOCP는 하나의 Thread가 하나 이상의 user request를 처리할 수 있도록 해준다.
   즉, Thread의 개수를 줄여 context switching의 횟수를 줄여서 비용을 절감하게 해준다.
       IOCP는 여기에서 Overlapped I/O가 완료되면 이를 감지하여 사용자에게 알려주는 역할을 한다.
-> Overlapped I/O Model(Non-Blocking + 비동기)의 확장 모델
-> 여기서 Port는 네트워크 상의 의미가 아닌, 작업 혹은 서비스를 전담하기 위해 만들어지는 객체이다.
    
19. Overlapped I/O는 무엇인가?
-> Overlapped I/O는 I/O에 대한 처리를 Device Driver에 권한을 넘김으로서 별도의 스레드없이 비동기로 둘 이상의 데이터 전송을 중첩시키는 것을 의미한다.
   Device Driver는 작업을 끝내면 유저 버퍼에 데이터를 채워넣기에 I/O에 대한 처리를 중첩해서 처리할 수 있다.
   
20. Non-Block Socket은 무엇인가?
-> TCP 소켓의 Blocking 모드는 소켓이 블록되는것을 의미한다.
   따라서 블록상태의 처리가 진행되기 전까진 다음 처리를 진행할 수 없다.
   애플리케이션이 만약 싱글스레드 모델이라면 블록상태에서 문제가 생겼을 경우 다음 처리를 하지못해 문제가 될 수 있다.
   Non-Block Socket은 Blocking 소켓의 단점을 보완하기 위해 등장한 개념으로 소켓이 블록되지 않고 즉시 소켓의 상태를 반환하게 된다.
   이렇게되면 소켓의 상태를 주기적으로 체크하고 다른 처리를 진행할 수 있게 된다.
   
21. Overlapped I/O와 Non-Block Socet의 차이점은 무엇인가?
-> Overlapped I/O는 I/O처리를 비동기로 처리하기 때문에 데이터 복사과정에서 Block되지 않는다.
   그리고 I/O처리를 순서대로 하지 않고 디스크에 가까운 순서대로 처리를 하며 Zero-Copy를 통해서 소켓 버퍼로의 복사를 건너뛰고
   유저 버퍼에 바로 데이터를 복사할 수 있다.
 
22. Zero-Copy란 무엇인가?
-> Zero-Copy의 목적은 디스크에 있는 데이터를 네트워크로 전송할 때 일어나는 바이트 카피를 최소화 하기위한 것이다.
   일반적으로 네트워크를 이용해서 데이터를 전송하려면 커널영역에서 사용자영역으로 데이터를 읽어들인 후
   다시 사용자영역에서 커널영역으로 데이터를 복사해야 한다.
   이러한 과정은 사용자영역에서 데이터를 조작하지 않고 바로 보내도 될시에 불필요한 과정이 된다.
   그렇기 때문에 커널과 사용자 영역을 넘나드는 과정을 거치지 않고 커널의 Read Buffer에서 Socket Buffer로의 복사만을
   거쳐서 커널과 사용자 영역간의 2번의 복사 과정을 생략할 수 있다.
   Overlapped의 입출력이 완료되면 Completion Port라고 하는 queue에 Completion Packet을 기록되고 
   스레드가 queue를 확인하여 Completion Packet이 있으면 완료된 내용을 받아갈 수 있다.
   Select방식과 비교해 봤을 때 소켓 하나에 스레드 하나를 할당해주는 것과 비교하여 소수의 스레드로
   I/O처리를 할 수 있다는 점에서 CPU자원을 효율적으로 사용한다고 할 수 있다.
   
</pre>
