# 개발상식

<pre>
1. API와 SDK를 설명하라.
-> API
    -> 응용 프로그램이 자신과 연관된 프로그램을 만들 수 있도록 제공하는 인터페이스이다.
       예를 들어 포토샵을 예로 들어보면, 포토샵 자체는 매우 유용한 프로그램이지만 포토샵 자체에 얼굴 보정 필터를 탑재하고 있지 않다.
       그래서 포토샵은 이 필터를 개발하려는 사람들을 위해서 다양한 인터페이스를 제공한다.
       이 인터페이스가 바로 API이다.
       즉, API는 시스템 호출보다 광범위하며 운영체제의 API를 시스템 호출이라고 말할 수 있다.
-> SDK 
    -> API 및 API 사용 메뉴얼, 프로그램 개발에 필요한 코드 편집기와 예뮬레이터 등등 각종 개발용 응용 프로그램까지 묶어 배포하는 개발툴 이다.
       한마디로 개발자를 위한 종합 선물세트라고 볼 수 있고, 대표적으로 안드로이드 스튜디오가 있다.
       
2. 객체지향형 프로그래밍과 5가지 원칙을 설명하라.
-> 객체지향형 프로그래밍(Object Oriented Programming, OOP)
    -> 캡슐화, 다형성, 상속성, 추상화, 정보은닉을 이용하여 코드 재사용을 증가시키고,
       유지보수를 감소시키는 장점을 얻기 위해서 객체들을 연결하여 프로그래밍을 하는 기법이다.
-> 특징
    -> 캡슐화 : 객체의 내용 중 숨기고 싶은 부분을 외부에서 접근할 수 없게 감출 수 있다.
                이는 정보의 은닉과 보호가 가능하다.
    -> 추상화 : 객체들의 공통된 특징을 파악해 정의해 놓은 설계 기법이다.
    -> 다형성 : 코드의 재사용성이 증가되고 폭 넓은 코드 구현이 가능하며, 개발속도를 향상 시킬 수 있다. ex) Overloading, Overriding
    -> 상속성(재사용성) : Class의 멤버(데이터)와 함수를 다른 Class에 물려주거나 물려받을 수 있는 기능으로 다형성을 확보할 수 있다.
    -> 정보은닉 : 캡슐화에서 가장 중요한 개념으로 다른 객체에게 자신의 정보를 숨기고 자신의 연산만을 통하여 접근을 허용하는 것이다.
-> 5가지 원칙
    -> 단일 책임 원칙(Single Responsibility Principle, SRP)
        -> 모든 클래스는 단 하나의 책임을 가진다. 클래스를 수정할 이유는 오직 하나여야 한다.
        -> 계산기 클래스는 계산을 하는 책임과 GUI를 나타내는 책임은 서로 분리되어야 한다.
        -> 계산기 클래스에 GUI를 나타내는 부분까지 있을 경우, 이는 SRP를 위반하는 것이 된다.
    -> 개방-폐쇄 원칙(Open-Closed Principle,OCP)
        -> 확장에 대해서는 개방되어 있어야 하지만, 수정에 대해서는 폐쇄되어야 한다.
    -> 리스코프 치환 원칙(Liskov Substitution Principle, LSP)
        -> 자식 클래스는 언제나 자신의 부모클래스를 대신할 수 있다.
        -> 부모클래스가 위치하는 자리에 자식 클래스를 대체하여도 잘 작동해야 한다.
    -> 인터페이스 분리 원칙(Interface Segregation Principle, ISP)
        -> 클라이언트는 자신이 이용하지 않는 메서드에 의존하지 않아야 한다.
        -> 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다.
        -> 하나의 일반적인 인터페이스보단 여러 개의 구체적인 인터페이스가 낫다.
    -> 의존 역전 원칙(Dependency Inversion Principle, DIP)
        -> 상위클래스는 하위클래스에 의존해서는 안된다.

3. 함수형 프로그래밍은 무엇인가?
-> 함수형 프로그래밍(Functional Programming)은 기능을 순수 함수로 나누어 구현(해결)하는 기법이다.
   자료 처리를 수학적 함수의 계산으로 취급하고 상태와 가변 데이터를 멀리하는 프로그래밍 패러다임의 하나이다.
   계산 가능성, 결정 문제, 함수 정의, 함수 응용과 재귀를 연구하기 위해 개발된 람다 대수에 근간을 두고 있다.

4. 순수 함수란 무엇인가?
-> 순수 함수란 같은 입력이 주어지면, 같은 출력을 반환해야 한다.
   즉, 부가 효과(Side Effect)가 존재하면 안된다. 부가 효과가 발생하면 순수 함수로서의 기능을 하지 못해 예측 불가능한 오류를 일으킬 수 있다.
   
5. 객체 지향 프로그래밍과 함수형 프로그래밍의 가장 큰 차이점은 무엇인가?
-> 객체 지향 프로그래밍은 클래스와 객체의 관계가 중심으로 구성되므로 상태, 멤버 변수, 메서드 등이 긴밀하게 의존한다.
   이는 멤버 변수가 가진 상태에 따라 결과가 변한다는 것이다.
-> 함수형 프로그래밍은 순수 함수와 보조 함수의 조합으로 상태를 제어하는 복잡성을 최소화하고 변수의 사용을 억제하여 
   상태 변경을 피해 최적화된 동작을 만들어낼 수 있다.
   
6. 라이브러리와 프레임워크의 차이점을 설명하라.
-> 라이브러리(Library)
    -> 단순하게 활용 가능한 도구들의 집합으로 개발자가 필요에 의해 만든 클래스를 호출하여 사용하는 방식이다.
       공통으로 사용될 수 있는 특정한 기능을 모듈화시킨 것으로 사용자가 직접 실행할 수는 없다.
-> 프레임워크(Framework)
    -> 소프트웨어의 특정 문제를 해결하기 위해 상호간 의존하는 클래스와 인터페이스의 집합이다.
       완성된 어플리케이션이 아니므로 개발자가 완성시켜야 하며, 특정 개념의 추상화를 제공하는 재사용 가능한 여러 클래스나 컴포넌트로 구성이 된다.
-> 차이점
    -> 궁극적인 차이점은 "개발의 주도성이 어디에 있는가?"로 설명할 수 있다.
    -> 라이브러리 : 개발자가 프로세스를 작성하며 필요한 코드를 가져다 사용
    -> 프레임워크 : 프로세스를 가지고 있으며, 개발자(사용자)는 프레임워크 안에서 필요한 코드를 작성
    -> 즉, 라이브러리는 개발자에게, 프레임워크는 개발자가 아닌 핵심 구조 안에 프로세스에 대한 주도성이 담겨있다.

7. 모든 클라이언트 요청과 응답을 JSP가 담당하는 구조(model1)와 클라이언트의 요청, 응답, 비즈니스 로직 처리 부분을 모듈화한 구조(model2)의
   차이점을 설명하라.
-> Model1
    -> 페이지(view)에 비즈니스 로직을 처리하기 위한 코드와 결과 출력을 관리하는 코드가 뒤섞여 있으며 해당 페이지에서 모든 정보를
       저장(model)하거나 처리(controller)한다.
    -> 장점 : 단순한 페이지 작성으로 구현이 쉬어 소규모 애플리케이션에 적합하다.
    -> 단점 : 재사용이 힘들고 가독성이 떨어지며 대규모 애플리케이션에서는 코드가 복잡해지면 유지보수가 어렵다.
-> Model2
    -> 클라이언트의 요청을 하나의 Web Container가 받아 알맞게 처리한 후 그 결과를 View로 전달한다.
    -> 장점 : 처리작업의 분리로 유지보수와 확장이 용이하다
    -> 단점 : 구조 설계를 위한 시간이 많이 소요되므로 개발 시간이 증가한다.

8. MVC 패턴은 무엇인가?
-> 소프트웨어 아키텍쳐 패턴으로 Model-View-Controller의 약자이다.
-> Model은 애플리케이션의 정보, View는 텍스트, 체크박스 항목 등과 같은 UI 요소이며, Controller는 데이터와 비즈니스 로직 사이의 
   상호동작을 관리한다.
-> UI(View)로 부터 비즈니스 로직(Model, Controller)을 분리하여 애플리케이션의 시각적 요소나 그 이면에서 실행되는 기능을 영향 없이
   쉽게 고칠 수 있다.

9. MVP 패턴은 무엇인가?
-> MVC가 가진 Model-View-COntroller 사이의 강한 결합을 해결하기 위해 등장한 소프트웨어 아키텍쳐 패턴으로 Model-View-Presenter의 약자이다.
-> View는 UI를 표현하며 사용자 정보의 입/출력만을 담당한다.
-> Presenter는 View로부터 입력을 Model에 요청하고, Model의 응답으로 View를 갱신하는 역할을 한다.
-> 이는 View가 수정되면 Presenter 또한 수정되야한다는 뜻으로, 이렇게 짜여진 아키텍쳐는 Presenter와 View가 강하게 결합하는 형태로 존재하게 된다.

10. MVVM 패턴은 무엇인가?
-> MVP패턴이 가진 강한 결합을 해결하기 위해 등장한 소프트웨어 아키텍쳐 패턴으로, Model-View-View Model의 약자이다.
-> View Model은 데이터를 제공하며, View는 View Model의 데이터로 UI를 갱신한다.
-> 리액트 프로그래밍과 관계가 깊다. Model, View, ViewModel 사이의 의존성(결합도)이 매우 낮고, 각각 분리된 모듈로써 존재하게 된다.
   이는 한 모듈이 변경되어도 다른 모듈에 영향을 주지 않는다는 의미이며, TDD(Test Driven Development, 테스트 주도 개발)와
   유지보수가 매우 쉬어진다.
-> 디자인 패턴인 Data Binding과 Command 패턴을 활용하여 제작된 구조이다.

11. REST, RESTful은 무엇인가? RESTful API는 무엇인가?
-> REST(Representataional State Transfer)는 웹의 장점을 최대한 활용할 수 있는 아키텍쳐이다.
-> 최근 서버 프로그램은 다양한 브라우저와 모바일 디바이스에서도 통신을 할 수 있어야 한다.
   REST 아키텍쳐는 이러한 HyperMedia API의 기본을 충실히 지키고 범용성을 보장한다.
-> 제약조건과 특징
    -> 클라이언트-서버 구조
    -> 무상태성(Stateless)
    -> 캐시 처리 가능(Cache)
    -> 유니폼 인터페이스
    -> 계층형 구조
    -> Code-On-Demand

12. 정적/동적 타이핑에 대해 설명하라.
-> 정적 타입 언어(Static/String type)
    -> C와 Java처럼 변수에 할당할 수 있는 타입을 지정해야만 하는 언어이며 이를 명시적 타입 선언(explicit type declaration)이라고 한다.
-> 동적 타입 언어(dynamic/weak type)
    -> JavaScript와 Python처럼 변수를 선언할 때 타입을 선언하지 않는 언어이며 이를 암시적 타입 선언(implicit type declaration)이라고 한다.
-> 정적 타입 언어 특징
    -> 변수의 타입을 변경할 수 없어 선언한 타입에 맞는 값만 할당
    -> 대부분의 정적 타입 언어는 컴파일 언어로써 컴파일 시점에 타입체크 한다.
    -> 타입의 일관성을 강제하여 안정적인 코드를 구현하고, 런터임(실행)에 발생하는 에러를 줄인다.
-> 동적 타입 언어 특징
    -> 미리 선언한 데이터의 타입의 값이 아니라, 어떤 타입이라도 자유롭게 할당할 수 있다.
    -> 선언이 아닌 할당에 의해 타입이 결정(타입추론)되며 타입의 변환이 자유롭다.
    -> 단, 타입의 일관성을 강제하지 않으므로 코드 구현과 런타임 간에 에러가 발생할 가능성이 있다.
    
13. TDD는 무엇인가?
-> TDD(Test-Driven Development, 테스트 주도 개발)
    -> 일반적인 개발 절차는 디자인(설계), 코드 작성, 기능 테스트로 이루어진다.
       그러나 TDD는 테스트가 주도하는 개발로써 그 절차가 다르다.
       우선적으로 테스트 코드를 작성하고, 테스트를 통과하는 minimal한 코드를 작성하는 형태이다.

14. Git과 Github는 어떻게 다른가?
-> VCS(Version Control System, 버전관리시스템)의 일종으로 Git은 로컬에서의 버전 관리, Github은 웹 기반의 버전 관리이다.
-> VCS란 소프트웨어의 코드를 추가 또는 변경하는 과정을 모두 기록하여 특정한 시점으로 돌아가거나, 문제가 생긴 파일을 복원하는 등의
   소프트웨어 개발 현장에서 사용하는 프로그램이다.
-> github는 Git Repository를 웹에 제공(호스팅)하는 서비스가 Github이다.

15. AOT와 JIT에 대해 설명하라.
-> JIT(Just In Time Compile) : JIT 컴파일러를 포함하며 브라우저에서 템플릿 컴파일을 진행하므로 매우 느리고 용량도 거대하다.
-> AOT(Ahead Of Time Complie) : 빌드시 템플릿을 먼저 컴파일을 한다. 따라서 빌드는 시간이 더 소요되나 브라우저에서는
                                컴파일이 실행되지 않기 때문에 훨씬 빠르다.
-> 따라서 개발 서버는 JIT 방식으로 빠르게 빌드하여 변경사항을 확인하고, 운영 서버에는 AOT 방식으로 전체 용량 감소 및 컴파일 시간을
   최소화 하는 방식으로 사용하는 편이다.
   
16. 점진적 향상법과 우아한 성능저하법의 차이를 설명하라.
-> 점진적 향성법(Progressive enhancement)
    -> 많은 테스트를 통해 말그대로 기능을 점진적으로 향상시키는 기법이다.
       기능이 제한된 브라우저의 애플리케이션을 개발할 때 주로 사용한다.
-> 우아한 성능저하법(graceful degragation)
    -> 신기술을 최신 기기에 적용하여 기능을 구현하고, 오래된 기기에서 동작하도록 기술 버전을 점차 낮추어 유사한 기능을 구현하는 것이다.
       최신 브라우저를 위한 어플리케이션을 구축하는 동시에 구형 브라우저에도 계속 동작하도록 하는 개발 방법이다.
       
17. 표준의 중요성에 관해 설명하라.
-> 표준에 의해 공통적인 기준과 상호 운용성이 명확해져 혁신이 빨라진다.
-> 좁은 의미
    -> 표준은 협업을 원화랗게 해주며, 개발에 따른 비용과 유지보수 용이성을 제공한다.
-> 넓은 의미
    -> 상호 운용성을 제공한다. 
    -> 비용절감
    -> 무역 활성화를 통한 시장 진출 도구로 활용할 수 있다.
    -> 사용자에 대한 자유도(선택의 자유)를 높일 수 있다.

18. 모노레포는 무엇인지 설명하라.
-> 모노레포(Monorepo)는 두 개 이상의 프로젝트 코드를 하나의 저장소에서 관리하는 기법이다.
    -> 코드의 재사용
        -> 여러 저장소에서 프로젝트를 진행하면 비슷한 로직을 각 저장소에서 중복 구현하는 때가 많은데,
           이를 공유하려면 저장소와 의존성을 추가해야한다. 모노레포를 적용하는 경우 하나의 저장소에서 하나의 키워드만으로
           모든 프로젝트가 같은 공통 코드를 사용할 수 있다.
    -> 의존성 관리
        -> 멀티레포 구조에서 각 저장소에 Linter를 따로 설치했지만 모노레포를 적용하면 그럴 필요가 없다.
    -> 작은 커밋과 PR
        -> 모노레포에서는 여러 패키지의 변경사항을 하나의 커밋과 PR로 제출할 수 있어 작업을 잘게 쪼갤 수 있다.
           물론 하나의 커밋에는 한 패키지의 변경사항만 기록하는 SRP를 지켜야 한다.
    -> 대규모 리팩토링
        -> 모노레포로 저장소를 운영해보니 하나의 파일에 대한 컨트리뷰터가 상당히 많아지므로 해당 로직을 이해하는 여러 사람이
           효율적으로 작성하는 방식에 대해서도 생각할 수 있으므로 대규모 리팩토링 유도가 가능하다.
    -> 팀 간 협업

19. CI/CD는 무엇인가?
-> CI(Continuous Integration)는 개발자를 위한 자동화 프로세스인 지속적인 통합
   CI를 성공적으로 구축하면 애플리케이션에 대한 새로운 코드 변경 사항이 정기적으로 빌드 및 테스트되어 공유 저장소에 통합된다.
   따라서 여러 개발자가 동시에 애플리케이션 개발과 관련된 코드 작업을 해도 충돌하지 않게 된다.
-> CD(Continuous Delivery or Continuous Deployment)는 지속적인 서비스 제공 또는 지속적인 배포이다.
    -> 지속적인 서비스 제공 : 애플리케이션에 적용된 변경 사항이 버그 테스트를 거쳐 저장소에 자동으로 업로드되는 것으로
                            운영팀은 이 저장소에서 애플리케이션을 실시간 프로덕션 환경으로 배포할 수 있다.
                            결국 개발팀과 운영팀 사이의 커뮤니케이션 문제를 해결한다.
    -> 지속적인 배포 : 저장소에서 애플리케이션의 변경 사항을 프로덕션 환경까지 자동으로 적용하는 것이다.
                      이는 운영팀의 수동 프로세스 과부하 문제를 해결한다.
-> CI/CD는 새로운 코드 통합으로 인해 개발 및 운영팀에 발생하는 문제(Integration Hell)의 해결책이다.
   하나의 애플리케이션에 여러 개발자가 각기 다른 기능을 수정하여 merge하는 경우 문제가 발생할 수 있다.
-> 문제점
    -> 모든 분기 소스 코드를 병합하는 경우, 반복적인 수작업에 많은 시간이 소모된다.
    -> 애플리케이션에 변경사항을 적용할 때 다른 개발자가 적용하는 변경사항과 충돌할 가능성이 있다.
-> 정리
    -> CI/CD는 지속적 통합 및 지속적 제공의 구축 사례만을 지칭하거나 지속적 통합, 지속적 제공, 지속적 배포라는 3가지 구축 사례
       모두를 의미하는 것일 수도 있다. 좀 더 복잡하게 설명하면 "지속적인 서비스 제공"은 때로 지속적인 배포의 과정까지 
       포함하는 방식으로 사용되기도 한다.

</pre>
