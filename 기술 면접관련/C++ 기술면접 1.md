# C++ 기술 면접 정리

<pre>
1. C와 C++의 차이는 무엇인가?
-> C언어는 절차지향 프로그래밍, C++언어는 객체지향 프로그래밍이다.
   절차지향은 순차적으로 처리하고 객체지향은 객체 중심으로 데이터와 메소드를 만들어 엮어 처리한다.
   속도적인 차이는 C++이 C언어보다 느리다. 그 이유는 템플릿이나 객체 지향 언어가 제공하는 기능에서 발생하기 때문이다.
   객체지향 언어의 특성상 데이터 타입 변환이나 다형성의 기능을 지원하기 위해 다수의 메모리 테이블을 추가한다.
   결과적으로 더 많은 메모리가 필요하며, 또한 메모리 관리하는 기능들이 추가되다 보니 전반적으로 느려지게 된다.
   
   객체 지향은 캡슐화, 상속화, 다형성, 추상화와 같은 특징을 가지며 구조화 되어있다.
   추상화 : 필요로 하는 속성, 행동을 추출하는 것
   캡슐화 : 낮은 결합도를 유지하도록 설계하는 것을 말하며 정보 은닉을 할 수 있다.
   상속 : 공통된 특성을 하나의 개념으로 정립하는 것을 말한다.
   다형성 : 다른 클래스의 객체가 같은 메시지를 받았을 때 각자 방식으로 반환하는 것을 말한다.
   
2. C++ 상속 관계와 다형성을 설명하라.
-> 상속은 자신의 멤버 변수와 멤버 함수를 자식 클래스에게 물려주는 것이다.
   부모 클래스의 모든 멤버들을 자식 클래스가 물려받는다.
   자식클래스가 부모 클래스의 속성을 재사용하는 것이다.
   
-> 다형성은 객체들의 타입이 다르면 똑같은 함수를 호출해도 서로 다른 동작을 하게된다.
   하나의 코드로 다양한 타입의 객체를 처리할 수 있는 기술이다.
   
3. constructor와 destructor는 무엇인가?
-> constructor는 생성자, destructor는 소멸자이다.
   C++ 에서 객체를 생성하거나 제거할 때 생성자와 소멸자가 사용된다.

-> 생성자를 이용하여 객체를 생성함과 동시에 멤버 변수를 초기화 할 수 있다.
   생성자는 특별한 메소드로 클래스 이름과 동일한 이름으로 구현된다.
   생성자를 따로 구현하지 않는다면 객체를 생성할 때 Default로 멤버 변수가 NULL로 초기화 된다.
   또한, 생성자는 입력 매개 변수를 다르게 함으로써 중복 정의할 수 있다.

-> 소멸자는 객체를 더이상 사용하지 않을 때 객체를 제거하기 위해 호출되는 함수이다.
   객체의 메모리 반환을 위해 사용한다. 
   클래스 이름 앞에 ~가 붙은 형태로 사용된다.
   
4. C++에서 default constructor는 무엇을 의미하는가?
-> default constructor은 기본 생성자이다.
   객체를 생성할 때 매개 변수를 선언하기 위해 생성자가 필요하다.
   이때 생성자가 없는 경우 컴파일러에 의해 자동적으로 생성자를 default constructor라고 한다.
   클래스에 생성자가 하나라도 선언되어있다면 default constructor은 자동으로 생기지 않아 오류가 발생할 수 있다.
   
5. Virtual는 왜 존재하는가?
-> 함수 앞에 virtual을 붙이면 가상 함수가 된다.
   가상함수는 파생 클래스에서 재정의할 것으로 기대하는 멤버 함수를 의미한다.
   즉, 부모 클래스에서 선언한 함수가 자식 클래스에서 재정의할 것을 알려준다. 
       상속에서 오버라이딩 할 때 사용한다.
   바인딩은 프로그램 요소의 성격을 결정해주는 것이다. 
   이 과정이 컴파일 시점에서 이뤄지면 정적바인딩 실행도중에 이뤄지면 동적바인딩이다.
   C++에서는 기본은 정적바인딩이다.

-> 동적바인딩을 하기 위해 가상함수를 바꿔 선언하여 사용한다.
   컴파일 시점에서 결정나기 때문에 가상함수를 사용하여 객체의 타입에 따라 멤버 함수를 선택한다.
   가상 함수는 컴파일 시점에 바인딩이 이뤄지지 않고 보류상태로 둔다.
   동적바인딩을 사용하면 어떤 포인터에 의해 접근되었는지에 상관없이 참조된 인스턴스의 실제 클래스형에 따라 재정의된 함수 호출이 가능하다.
   
6. \n과 endl의 차이는 무엇인가?
-> 둘의 차이는 endl은 출력 버퍼를 비워준느 과정(flush)이 들어가 있어서 \n보다 느리다.
   버퍼를 즉시 비우고 싶다면 endl을 그렇지 않다면 \n을 사용한다.
   
7. malloc과 new의 차이는 무엇인가?
-> malloc과 new 모두 동적할당을 하기 위해 사용된다.
   보통 malloc은 C언어에서 new는 C++언어에서 사용된다.
   malloc은 함수이고, new는 연산자이다.
   malloc은 heap 영역에서, new는 dynamic memory에서 할당이 된다.
   malloc은 초기값 지정이 불가능하고, new는 초기값 지정이 가능하다. new는 객체에서 생성자를 자동으로 호출하고 초기화해준다.
   
8. struct와 class의 차이는 무엇인가?
-> C++에서 struct와 class는 객체를 구조화 역할을 한다.
   struct에서는 기본 한정자가 public이고, class에서는 private이다.
   구조체와 class 모두 상속이 가능하고 함수를 추가할 수도 있다.

9. 얕은 복사와 깊은 복사
-> 객체를 생성하고 초기화시킬 때 멤버 변수를 어떻게 초기화하느냐에 따라 얕은 복사, 깊은 복사를 나눈다.
-> 얕은 복사 : 실제 데이터가 아닌 단지 메모리 주소만을 복사한다.
-> 깊은 복사 : 변수가 관리하는 리소스 자체를 복사(새롭게 메모리를 할당)하여 새롭게 멤버 변수에 복사한다.
              얕은 복사에 비해 작업 시간과 리소스의 소모가 따른다.
              
10. 입출력 실행속도 높이는 방법
-> C++에서 printf, scanf보다 cin, cout은 속도가 현저히 떨어진다.
   그럴 때 ios::sync_with stdio(fasle) 코드를 삽입하여 실행속도를 줄일 수 있다.
   C++의 iostream을 C의 stdio와 동기화를 끄게 된다.
   iostream과 stdio의 버퍼를 모두 사용하므로 딜레이가 발생되는데 이를 끊어 실행 속도를 높아지게 한다.
   
11. C++ 프로그램 빌드 과정을 설명하라.
-> 전처리 - 컴파일러 - 어셈블러 - 링커
   컴퓨터는 0과 1로만 이루어져있기 때문에 컴퓨터가 이해할 수 있도록 만들어 주어야 한다.
   이런 과정을 빌드라고 한다.

-> 전처리(preprocessing) : 코드의 주석을 제거, define을 치환하는 기능을 한다.
   컴파일러(compiler) : 어셈블리 파일로 변환한다. 어셈블리(저수준 언어)는 CPU 명령어 조합이다.
   어셈블러(assembler) : 오브젝트 파일로 변환한다. 오브젝트 코드는 0과 1로 이루어진 코드를 말한다.
   링커(linker) : 오브젝트 파일들을 묶어서 실행 코드 파일로 변환한다.
                  운영체제가 로딩할 수 있도록 주소 정보를 할당한 파일을 만들어 낸다.
                  번역된 파일을 하나로 연결해 실행가능한 파일로 만들어준다.
  
-> 컴파일 언어의 장점 : 빌드가 완료된 실행가능한 파일을 실행 속도가 빠르다.

12. 해시테이블과 STL map에 대해 설명하라.
-> 해시테이블의 값은 키에 대한 해시 함수를 호출하여 저장한다.
   값은 정렬된 순서로 보관되지 않으며 값을 저장한 인덱스를 찾기 위해 키를 사용한다.
   삽입 및 검색은 분할상환적으로 O(1) 시간에 수행된다.
   또한, 잠재적 충돌을 고려하여 구현해야 한다.
   보통 충돌되는 값을 서로 체이닝하여 이 문제를 해결하는데, 특정 키에 대응되는 인덱스 위치에 모든 값을 연결리스트로 묶는 방법으로 해결한다.

-> Map은 키를 기준으로 만든 red-black tree에 키와 값 쌍으로 보관한다.
   충돌을 처리할 필요가 없으며 트리의 균형이 유지되므로 삽입, 검색 연산의 시간은 O(logN)으로 보장된다.

13. 스마트 포인터에 대해 설명하라.
-> new 키워드를 사용해 동적으로 할당받은 메모리는 반드시 delete 키워드를 사용해 해제해줘야 한다.
   하지만, 개발자의 실수나 잘못된 설계로 인하여 해제가 안되는 경우가 많다.
          이러한 경우를 방지하고 안전한 사용을 위해 등장하게 된 것이 스마트 포인터이다.

-> unique_ptr는 하나의 스마트 포인터만이 특정 객체를 소유할 수 있도록 객체에 소유권 개념을 도입한 스마트 포인터이다.
   해당 객체의 소유권을 갖고 있을 경우에만 소멸자가 해당 객체를 삭제할 수 있다.
   
-> shared_ptr는 하나의 특정 객체를 참조하는 스마트 포인터가 총 몇개 인지를 참조하는 스마트 포인터이다.
   참조 횟수가 0이 되면 delete 키워드를 사용해 자동으로 해제된다.
   
14. 가상함수의 동작 원리에 대해 설명하라.
-> 컴파일러는 가상함수가 1개라도 존재하는 각각의 클래스에 대해서 가상함수 테이블을 생성한다.
   테이블 안에는 클래스의 멤버함수와 가상함수가 함수의 식별자 정보를 담은 key와 함수의 주소 정보를 담은 value를 갖고 테이블을 구성한다.
   가상 함수를 가진 클래스의 인스턴스가 가상함수를 호출할 때, 가상 함수 테이블의 주소값을 가지는 가상 포인터를 통해
   주소를 참조받고, 그 주소의 가상함수 테이블을 조사하여 호출한 함수 이름에 맞는 가상 함수를 호출한다.
   
-> 하위 클래스가 상위 클래스의 가상 함수를 오버라이드하지 않으면 하위 클래스의 가상테이블은 상위 클래스의 가상 함수 주소를 보관한다.
   이 가상테이블을 사용해 가상 함수가 호출될 때 어느 주소에 있는 함수가 호출되어야 하는지를 결정한다.

15. 포인터와 배열의 차이를 설명하라.
-> 배열은 변수 선언과 함께 자신의 데이터를 저장할 공간을 배열의 크기만큼 연속적인 공간을 가진다.
   포인터는 자신이 데이터를 저장할 공간을 갖지 않고 저장할 공간이 있는 위치를 저장하는 메모리 번지를 저장한다.

-> 포인터와 배열은 둘다 변수 자체는 메모리 번지를 뜻하지만, 배열은 포인터 상수여서 다른 번지를 가리킬 수 없고,
   포인터는 변수이므로 대입이 가능하다.
   포인터 변수는 증감 연산자가 사용가능하지만, 배열은 상수이므로 사용할 수 없다.
   
16. 정적 바인딩과 동적 바인딩을 설명하라.
-> 바인딩은 함수가 호출될 때 함수의 주소를 연결해 주는 것을 말한다.

-> 정적 바인딩 : 컴파일 시점에 일어나고 프로그램 실행 과정에서 변하지 않고 유지되는 바인딩이며,
                컴파일 시 결정되므로 속도가 빠르고 에러를 조기에 발견할 수 있다는 장점이 있다.
                단점으로는 컴파일 이후 변경이 불가능하다는 점이 있다.
                일반함수, 일반변수 할당

-> 동적 바인딩 : 런타임 중 결정되며 실행 과정에서 변경되는 바인딩을 말한다.
                가상 함수 호출시 오버라이딩된 가상 함수를 동적으로 찾아 호출할 때 사용하며,
                런타임 중 자유롭게 바뀔 수 있어 적응성이 높지만, 타입 체크로 수행 속도 저하가 발생할 수 있다.
                동적 바인딩을 사용하는 이유는 어떤 포인터에 의해 접근되었는지 상관없이
                참조된 인스턴스의 실제 클래스에 따라 재정의된 함수를 호출할 수 있기 때문이다.
                가상함수, 변수동적 할당
     
17. rvalue, lvalue의 차이를 설명하라.
-> lvalue는 프로그램이 접근할 수 있는 주소가 있다. 변수 명, const 변수, 배열 요소, lvalue를 참조를 반환하는 함수 등의 표현식이 있다.

-> rvalue 표현식은 프로그램에서 액세스할 수 있는 주소가 존재하지 않는다.

18. static cast와 dynamic cast의 차이를 설명하라.
-> 정적 캐스트는 형 변환에 대한 타입을 런타임에 확인하지 않고 컴파일 시 정적으로 수행한다.
   동적 캐스트는 런타임에 상속 계층 관계를 가로지르거나 다운캐스팅할 때 사용된다.

-> 기본 클래스 객체에 대한 포인터와 레퍼런스 타입을 자식 클래스의 타입으로 변환할 수 있고 nullptr이거나 예외를 보고 
   실패를 판별할 수 있다. 또한, 동적 캐스트는 다형성을 띄지 않는 객체간 변환은 불가능하고 컴파일 에러가 발생한다.
   
-> 정적 캐스트는 정적으로 형변환을 해도 아무런 문제가 발생하지 않는 것은 이미 어떤것인지 알고 있을 경우이며,
   동적 캐스트는 동적으로 형변환을 시도한다는 것은 그것의 타입을 반드시 알아봐야 한다는 것을 의미한다.

-> 해당 타입에 대해 명확히 알고 있다면 정적 변환을 사용하여 비용을 절약하는 것이 좋다.
 
19. 파이썬과 C++의 차이를 설명하라.
-> 파이썬과 C++ 모두 객체지향 언어이다.
   파이썬은 인터프리터 언어로 소스 코드를 한줄씩 읽어 명령을 처리하기 때문에 컴파일러 언어보다 속도가 느리다.
   C++는 컴파일러 언어이며 코드를 한번에 어셈블리 언어로 번역후 한번에 실행하는 언어이다.
   
20. dynamic linking, static linking의 차이를 설명하라.
-> linking은 여러 개의 코드와 데이터(라이브러리)를 연결해 실행할 수 있는 하나의 파일로 만드는 작업을 말한다.

-> static linking은 실행파일을 생성할 때 라이브러리를 같이 포함시켜서 exe파일로 만드는 것을 말한다.
   만약 여러 프로그램에서 라이브러리 A를 사용할 때, 해당 프로그램의 오브젝트 파일 각각에 라이브러리 A의 정보가 포함된다.
   중복이 발생하여 메모리 공간을 낭비하게 된다. 또한, 라이브러리에 변경이 생기면 변경 적용을 위해 다시 컴파일하여 링킹해야 한다.
   모든 코드는 하나의 실행 모듈에 담기기 때문에 불일치가 발생하지 않고 동적 링킹 방식보다 빠르다는 장점이 있다.
   
-> dynamic linking은 오브젝트 파일을 만들 때, 프로그램에서 사용하는 모든 라이브러리들을 복사하지 않고 해당 주소만 가지고 있다가
   런타임에 실행 파일과 라이브러리가 메모리에 적재될 때 해당 라이브러리의 주소로 가져오는 방식이다.
   이 방식을 사용하면 여러 프로그램에서 라이브러리 A를 사용한다 해도, A의 주소 하나만 가지고 있으면 된다.
   따라서, 오브젝트 파일의 크기가 작아 메모리 공간을 아낄 수 있게 된다.
   매번 주소로 가야하므로 오버헤드가 발생하여 정적 링킹보다 느리다.
   또한, 불일치 문제가 발생할 수 있다. 
   왜냐하면, 프로그램에서 A를 동적 링킹 방식으로 할 때, A가 제거될 경우 더 이상 참조할 함수가 없게 되기 때문이다. 
   
21. Call by Value와 Call by Reference에 대해 설명하라.
-> Call by Value : 인자로 받은 값을 복사하여 처리를 하는 방법
    -> 장점 : 복사하여 처리하기 때문에 안전하다.
    -> 단점 : 복사를 하기 때문에 모리가 사용량이 늘어난다.
    
-> Call by reference :  인자로 받은 값의 주소를 참조하여 직접 값에 영향을 주는 방법.
    -> 장점 : 복사하지 않고 직접 참조를 하기에 빠르다.
    -> 단점 : 직접 참조를 하기에 원래 값이 영향을 받는다.(리스크)

22. STL에 대해 설명하라.
-> Standard Template Library로 C++의 템플릿을 사용하여 표준으로 정리된 라이브러리이다.
   반복자/컨테이너/알고리즘/함수 객체등의 라이브러리로 구성된다.
   
23. 컨테이너가 무엇인지 설명하라.
-> 같은 타입의 여러 객체를 저장하는 일종의 집합이라고 할 수 있다.
   컨테이너는 클래스 템플릿으로 컨테이너 변수 선언할 때 컨테이너에 포함할 요소의 타입을 명시할 수 있다.
   
24. 시퀀스 컨테이너, 연관 컨테이너, 어댑터 컨테이너에 대해 설명하라.
-> 시퀀스 컨테이너 : 자료를 입력한 순서대로 저장하기 때문에 저장 검색 알고리즘이라고 불린다.
                   많지 않은 양의 자료/검색속도가 중요하지 않은 경우에 사용되며 vector, list, string, deque등이 이에 해당한다.

-> 연관 컨테이너 : 일정한 규칙에 따라 자료를 조직화화여 저장하는 것을 말한다.
                  자료를 정렬하여 저장하기 때문에 검색에 유리하고 많은 양의 자료/빠른 검색이 중요할 때 사용한다.
                  대표적으로 map, set이 이에 해당한다.

-> 어댑터 컨테이너 : 시퀀스 컨테이너를 변형시켜 스택, 큐, 우선순위 큐 형태로 저장하는 것을 말한다.

25. array, vector의 차이를 설명하라.
-> array : 인덱스 기반 기본 자료구조
           메모리 효율성이 높다, 고정된 길이, 요소의 접근이 빈번히 발생, 연속적인 메모리 공간, 인덱스 기반
-> vector : 요소들을 순차적으로 저장할 수 있는 컨테이너
            배열보다 메모리 공간이 더 차지, 가변 길이, 요소의 삽입과 삭제가 빈번하게 발생, Template 클래스, 인덱스 기반아님
         
26. 추상 클래스와 인터페이스의 차이를 설명하라.
-> 추상 클래스는 순수 가상함수를 하나 이상 갖고 있는 클래스이다.
   추상 클래스가 되면 인스턴스를 만들수 없게 된다. 다른 자식 클래스를 파생시켜 모든 순수 멤버 가상함수를 오버라이딩하면
   해당 자식 클래스부터 인스턴스를 다시 생성할 수 있다.
   즉, 추상 클래스는 말 그대로 추상적인 형태만 제안하고 실제 구현은 자식 클래스로 미루기 위한 용도이다.

-> 추상 클래스는 생성자 멤버변수 일반 메소드를 자유롭게 포함할 수 있으며, 여기 1개 이상의 추상 메소드가 포함되어져 있으면 된다.
   그러나, 인터페이스는 추상 메소드 만으로만 이루어져 있다.
   
27. 가상함수와 순수 가상함수란?
-> virtual 키워드를 함수 앞에 붙이면 가상함수로 선언이 된다.
   자식 클래스에서 재정의 할 것으로 기대하는 멤버함수를 의미한다.
   이러한 가상함수는 자신을 호출하는 객체의 동적 타입에 따라 실제 호출할 함수가 결정이 된다.
   순수 가상 함수와 다른 점은 함수의 선언 내부 구현까지 자식 클래스에게 전달하기 위한 함수이다.
   
-> 순수가상함수란, 자식 클래스에서 반드시 재정의해야 하는 멤버 함수를 의미한다.
                  이러한 순수 가상 함수는 일반적으로 함수의 동작을 정의하는 본체를 가지고 있지 않다.
                  따라서 자식 클래스에서 재정의 하지 않으면 사용할 수 없다.
                  구현 대신 가상함수 선언 맨뒤에 =0값을 대입하면 해당함수는 순수가상함수가 된다.
                  
28. volatile 키워드를 설명하라.
-> voliatile로 선언한 변수는 컴파일러가 해당 변수를 최적화에서 제외하여 항상 메모리에 접근하도록 하는 키워드이다.

29. 언제 malloc을 사용하고 new를 사용해야 하는지 설명하라.
-> 재할당이 빈번하게 일어나는 경우 realloc이 가능한 malloc을 사용하는 것이 옳다.
   realloc은 malloc으로 동적할당된 메모리 크기를 변경시켜주는 함수이다.
   realloc에도 한계는 있다. 새로운 영역을 할당 받더라도 현재 내용을 잃어버리는 일은 절대 없다.
   그러나, 동적으로 할당한 메모리가 있고 여러 개의 포인터가 공유하고 있다면 절대 realloc을 사용하면 안된다.
   Dangling Pointer가 발생한다. 그 원인은 메모리가 부족해 확장을 못하고 새로운 공간으로도 옮길수도 없다면 nullptr을 반환한다.
   원래 공간에 값은 남아있는데 주소를 잃어버리게 된다.

  * Dangling Pointer : 포인터가 여전히 해제된 메모리 영역을 가리키고 있는 포인터
  
30. null과 nullptr의 차이점을 설명하라.
-> 기본의 NULL의 의미는 0으로 치환되어 상수로 취급되어 처리되었다.
   반면에 nullptr은 포인터 취급을 받는다. 따라서 nullptr을 씀으로서 오버로딩 같은 상황에서 NULL이 갖던 모호함을 해결할 수 있다.
   포인터가 들어와야 하는데 NULL이 들어왔을 때
   
31. inline함수는 무엇인가?
-> 컴파일러가 함수를 호출하는 대신 그에 대응하는 함수 코드를 대체한다는 것을 의미하여 함수 호출없이 삽입된 함수 코드를 
   그 자리에서 처리하므로 해당 함수를 수행하기 위해 프로그램이 다른 주소를 점프했다가 되돌아올 필요가 없어 속도면에서 유리하다.
   
32. 하위 클래스의 소멸자를 만들어야 하는 이유는?
-> 상속을 받는 자식 클래스의 인스턴스를 생성하고 다형성의 원칙에 따라 해당 객체를 부모 클래스 타입의 변수에 할당하였다고 가정할 때
   소멸시 정상적으로 부모 클래스의 소멸자는 호출되는 반면 자식 클래스의 소멸자는 호출되지 않는다.
   해결방법은 참조를 만들고 상위 클래스를 가상 소멸자로 만들어준다.

33. 가상소멸자란 무엇인가?
-> 객체의 소멸과정에서는 포인터 변수의 자료형에 상관없이 모든 소멸자가 호출되어야 하는데
   그 해결방법이 가상 소멸자이다.
-> 가상 소멸자가 호출되면, 상속 구조의 맨 아래에 있는 유도 클래스의 소멸자가 대신 호출되면서, 기초 클래스의 소멸자가 순서대로 호출된다.
   그리하여 메모리 누수 문제가 해결된다.
   
34. 하이딩, 오버로딩, 오버라이딩의 차이는?
-> 하이딩 : 자식 멤버와 부모의 멤버 간의 서로 메소드를 가리키는 것을 의미한다.
-> 오버로딩 : 함수 중복 정의 같은 이름의 함수에 매개변수만 다르게 사용하여 매개변수에 따라 다른 함수가 실행되는 것을 말한다.
-> 오버라이딩 : 상속받을 때 부모클래스의 함수를 자식클래스에서 재정의하여 사용하는 것을 말한다.

35. auto란?
-> C++11 에서 추가된 기능으로 초기값을 입력하면 컴파일러에게 타입을 추론하도록 명령하는 키워드이다.
   컴파일 타입에 실행된다.

36. Explict 키워드는 무엇인가?
-> C와 C++의 공통 특징 중 하나인 묵시적 형변환을 막아주는 키워드이다.
   묵시적 형변환 때문에 발견하기 힘든 어려운 버그가 생기는 것을 방지하기 위해 도입된 키워드이다.

37. 동적할당이 필요한 이유는?
-> 동적메모리 할당은 입력값에 의존적인 프로그램을 만들어야 하는 경우 유용하게 쓰일 수 있다.
   예를 들어 사진이나 영상 등 어떤 파일을 읽어야 하는데 읽기 전에는 그 크기를 모르기 때문에
   메로리에 얼마나 공간이 필요한지 알수가 없는데 이럴때는 동적할당이 꼭 필요하다.
-> C++ 프로그램이 사용하는 메모리는 다음 3가지로 구분되어 있다.
    -> DATA : 전역변수와 스택변수가 저장되는 곳
    -> STACK : 모든 지역변수들이 저장되는 곳
    -> HEAP : 할당해야 할 메모리크기를 프로그램의 실행중에 결정해야 하는 경우 사용할 수 있는 메모리(동적할당)
-> 이 HEAP 영역을 사용하기 위해서 동적할당이 필요하고 동적할당을 위해서는 포인터를 사용해야 한다.

38. char*, char[]와 string의 차이는?
-> char* : 문자열 첫 글자의 시작 주소를 가리키며 읽기만 가능하다.
-> char[] : char*와 달리 문자열 하나하나 수정 가능하며, 마지막 지정 문자가 들어간다.
-> string : class 객체이며, 문자열의 크기를 동적으로 변경이 가능하다.
            마지막 지정 문자가 없고, 문자열 처리를 하는 기능을 제공하여 다루기 쉽다.
 
39. friend 클래스란?
-> friend 클래스는 friend로 선언된 다른 클래스의 private 및 protected 멤버에 접근할 수 있게 만듭니다.
    특정 상황에서 클래스 내에 접근하지 못하도록 private 제한을 두었는데, 필요의 경우 해당 클래스나 함수에서
    접근이 가능하도록 사용하는 것이 friend 클래스 및 함수이다.
 
40. 연산자 오버로딩은 무엇인가?
-> C++ 에서 제공하는 기본 타입이 아닌 클래스 타입, 즉, 사용자 정의 타입에도 연산자를 사용할 수 있게 하는 문법이다.
   다시 말해, 오버로딩이 같은 이름의 함수를 통해 여러 기능을 수행하였다면, 
             이번에는 같은 이름을 가진 연산자들이 상황에 맞추어 여러 기능을 수행한다는 의미
  
41. Template 이란?
-> 함수나 클래스를 개별적으로 다시 작성하지 않아도, 여러 자료 형으로 사용할 수 있도록 만들어 놓은 틀.
-> 함수 템플릿(Function Template)와 클래스 템플릿(Class Template)으로 나누어진다.
-> ex) Template 사용전                    Template 사용 후
       int sum(int a, int b){             template <typename T>
         return a + b;                    T sum(T a, T b){
       }                                     return a + b;
       double sum(double a, double b){    }
         return a + b;
       }
       
42. CRITICAL SECTION은 무엇인지 설명하라.
-> CRITICAL SECTION은 임계 영역을 뜻한다.
-> 임계 영역이란, 다중 쓰레드에서의 객체 접근을 보호하기 위한 방법 중 하나이다.
                 설정한 구간은 한 번에 하나의 쓰레드에서만 사용이 가능하다.
                 프로세스 내에 여러 쓰레드가 있는 환경에서 설정한 CRITICAL SECTION에 어떤 쓰레드가 먼저 진입하여
                 CRITICAL SECTION을 벗어나지 않은 상태에서는 동일 프로세스의 다른 쓰레드에서 해당 영역에 진입하지 못하게 한다.
-> ex) CRITICAL_SECTION cs; // CRITICAL SECTION 선언
       InitializeCriticalSection(&cs); // CRITICAL SECTION cs 초기화
       EnterCriticalSection(&cs); // CRITIVAL SECTION 시작부 지정
           // CRITICAL SECTION : 한번에 하나의 쓰레드에 의해서만 실행될 수 있는 영역
       LeaveCritiaclSection(&cs); // CRITICAL SECTION 끝 지정
       DeleteCriticalSection(&cs); // 종료 시점에 CRITICAL SECTION cs 초기화
</pre>
