# 자료구조와 알고리즘
<pre>
1. 배열 리스트(Array List)와 연결 리스트(Linked List)의 차이점을 설명하라.
-> 배열 리스트 특징
    -> 데이터의 수에 따라 더블링을 통해 크기를 조절하므로 가변적
    -> 무작위 접근으로 O(1)에 해당하는 시간 복잡도에 데이터 탐색이 가능
    -> 중간 데이터 변경이 있을 경우 원소의 이동이 많아지게 됨
-> 연결 리스트 특징
    -> 포인터로 노드와 노드를 연결하여 관리하므로 데이터 변경시 이동이 없다.
    -> 포인터로 인해 메모리가 더 소비된다.
-> 즉, 데이터의 변경이 잦다면 연결리스트, 조회가 잦다면 배열리스트

2. Hash에 대해 설명하라.
-> 임의의 크기를 가진 데이터를 고정된 데이터의 크기로 변환시키는 것
    -> Hash를 사용하면 즉시 저장하거나 찾고자 하는 위치를 참조하므로 향상된 속도로 처리가 가능

3. HashTable의 이중 해쉬에 대해 설명하라.
-> 해시테이블은 효율적인 탐색을 위해 key-value로 대응시킨다.
   해시테이블은 구현하기 위해선 연결리스트와 해시함수가 필요하다.
   해싱은 임의의 길이의 값을 해시 함수를 통해 고정된 크기의 값으로 변환하는 작업을 말하는데, 키 값을 해시 코드로 변환한 후,
   해당 해시 코드로 배열의 인덱스를 참조하여 값을 찾는다.
   충돌이 발생할 수 있으며, 최악의 경우 O(N), 일반적으로 잘 구현된 경우는 O(1)의 시간 복잡도를 가지게 된다.
   충돌은 Chaining, Open addressing 등의 방식으로 해결할 수 있다.
   
4. 이진 트리와 트리 순회법에 대해 설명하라.
-> 각 노드가 최대 두 개의 자식을 갖는 트리구조로써, 모든 트리가 이진 트리는 아니다.
   효율적인 이진 탐색이 가능하면서 자료 입력과 삭제의 시간 복잡도가 O(h)라는 특징이 있다.
   왼쪽 트리의 값은 반드시 부모 노드보다 작아야 하며, 오른쪽 트리의 값은 부모 노드보다 커야한다.
-> 이진 트리 순회 방식 : 전위 순회(현재 노드-> 왼쪽 -> 오른쪽)
                        중위 순회(왼쪽 -> 현재 노드 -> 오른쪽)
                        후위 순회(왼쪽 -> 오른쪽 -> 현재노드)

5. Red-Black-Tree 구조를 설명하라.
-> 자가 균형 이진 탐색 트리로써 연관 배열 등을 구현하는데 쓰이는 대표적인 자료구조
-> 특징
    -> 복잡한 자료구조이나 실사용에서 효율적이다.
    -> 자료의 삽입과 삭제, 검색에서 최악의 경우에도 일정한 실행 시간을 보장한다.
    -> 트리에 n개의 원소가 있을 때 O(logn)의 시간복잡도로 삽입, 삭제, 검색이 가능하다.
-> 동작
    -> 레드-블랙 트리의 읽기 전용(read-only)동작(탐색 등) 이진 탐색 트리의 읽기 전용 동작의 구현을 변경하지 않아도 된다.
        -> 레드-블랙 트리가 이진 탐색 트리의 특수한 한 형태이기 때문이다.
    -> 삽입과 삭제의 경우 이진 탐색 트리의 구현에 따른 동작만으로는 레드-블랙 트리의 특성을 만족하지 못한다.
        -> 레드-블랙 트리의 특성을 만족하게 만들기 위해서는 O(logn)또는 O(1)번의 색 변환과 최대 3회의 트리 회전이 필요하다.
        -> 삽입과 삭제는 복잡한 동작이지만, 그 복잡도는 여전히 O(logn)이다.
        
6. B+ Tree 구조는 무엇인가?
-> B+ 트리(Quaternary Tree)
    -> 키에 의해서 각각 식별되는 레코드의 효율적인 삽입, 검색과 삭제를 통해 정렬된 데이터를 표현하기 위한 트리 자료구조
-> 특징
    -> 동적이며, 각각의 인덱스 세그먼트(블록 또는 노드)내에 최대와 최소범위 키의 개수를 가지는 다계층 인덱스로 구성
    -> 모든 레코드들이 트리의 가장 하위 레벨에 정렬되어 있으며 오직 키만 내부 블록에 저장
    -> 블록-지향적인 Storage Context에서 검색을 효율적으로 할 수 있다.
    -> 바이너리 서치 트리에 비해 B+ 트리 노드의 fanout(한 노드의 자식 노드의 수)이 훨씬 높아 검색에 필요한 I/O동작 횟수 감소 가능
    
7. 최소 스패닝 트리(Minimun Spanning Tree, MST)는 무엇인가?
-> 그래프 G의 스패닝 트리 중 edge weight 값이 최소인 스패닝 트리를 말한다.
   n개의 vertex를 가지는 그래프에서 반드시 (n-1)개의 edge만을 사용해야 하며 사이클이 포함되어서는 안된다.
   Kruskal과 Prim을 통해서 MST를 구현할 수 있다. 크루스칼의 경우 그래프의 간선들을 오름차순으로 정렬하여
   가장 낮은 가중치의 간선부터 차례로 MST에 집합체 추가하는 그리디 방식을 사용한다.
   Prim의 경우는 시작 정점부터 단계적으로 트리를 확장하는 방법이다.
-> 스패닝 트리란? 그래프 G의 모든 vertex가 cycle없이 연결된 형태를 말한다.

8. Heap 구조는 무엇인가?
-> 힙(Heap) : 최댓값 및 최솟값을 찾아내는 연산을 빠르게 하기 위해 고안된 완전이진트리를 기본으로한 자료구조
-> 특징
    -> 부모 노드의 키값이 자식 노드의 키값보다 항상 큰 힙인 최대 힙과 
       부모 노드의 키값이 자식 노드의 키값보다 항상 작은 힙인 최소 힙이 존재한다.
    -> 키 값의 대소관계는 오로지 부모 노드와 자식 노드 간에만 성립하며 형제 사이에는 대소관계가 정해지지 않음
    -> 각 노드의 자식 노드의 최대 개수는 힙의 종류에 따라 다르나 대부분의 경우는 자식 노드의 개수가 최대 2개인 이진 힙을 사용한다.
    -> 힙에서는 가장 높은(혹은 가장 낮은) 우선 순위를 가지는 노드가 항상 뿌리 노드에 오게되는 특징이 있다.
        -> 이를 이용하여 우선순위 큐를 구현한다.

9. Graph 구조에 대해 설명하라.
-> vertex(정점)과 edge(간선)으로 구성된 한정된 자료구조
-> 특징
    -> 연결되어 있는 객체 간의 관계를 표현할 수 있는 자료구조
    -> 그래프에는 방향성 or 무방향성이 존재
    -> 그래프는 여러 개의 고립된 부분 그래프로 구성이 가능하다.
        -> 모든 정점 쌍(pair of vertices)간에 경로가 존재하는 그래프는 연결 그래프라고 부른다.
    -> 그래프 간에 사이클이 있을수도 없을수도 있다.
-> 종류
    -> 인접 그래프(Adjacency List)
        -> 그래프를 표현할 때 사용되는 가장 일반적인 방법
        -> 모든 정점(혹은 노드)를 인접 리스트에 저장
            -> 무방향 그래프에서 (a,b) 간선은 두 번 저장
            -> 한 번은 a정점에 인접한 간선을 저장하고 다른 한번은 b에 인접한 간선을 저장한다.
            
10. 다익스트라 알고리즘에 대해 설명하라.
-> 특정 노드에서 출발하여 다른 모든 노드로 가는 최단경로를 계산하는 알고리즘(방향 그래프)
-> 다익스트라 최단경로 알고리즘은 음의 간선이 없을 때 정상동작
-> 그리디 알고리즘으로 분류(매상황 가장 비용이 적으 노드를 계산하여 최단거리 테이블 갱신)
동작과정
-> 출발노드 설정
-> 최단 거리 테이블 초기화
-> 방문하지 않은 노드 중에서 최단 거리가 짧은 노드를 선택
-> 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신
-> 3,4번 반복

10-1. 다익스트라 알고리즘의 성능향상을 위해서는 어떻게 해야하는가?
-> 기존 다익스트라 알고리즘의 동작과정에서 출발노드 설정을 할 때 우선순위 큐(힙)을 이용하여 방문 처리를 한다.
성능분석
-> 힙 자료구조를 이용하는 다익스트라 알고리즘의 시간복잡도는 O(ElogV)이다.
-> 노드를 하나씩 꺼내 검사하는 반복문(while)은 노드의 개수 V이상의 횟수로는 처리되지 않는다.
    -> 결과적으로 현재 우선순위 큐에서 꺼낸 노드와 연결된 다른 노드들을 확인하는 총 횟수는 최대 간선의 수(E)만큼 연산이 수행될 수 있다.
-> 직관적으로 전체과정은 E개의 원소를 우선순위 큐에 넣었다가 모두 빼내는 연산과 유사하다.
    -> 시간복잡도는 O(ElogE)로 판단할 수 있지만, 중복 간선을 포함하지 않는 경우 O(ElogV)로 정리가 가능하다.

10-2. 다익스트라 알고리즘에서 음수 가중치가 있으면 안되는 이유를 설명하라.
-> 다익스트라 알고리즘에서 "지금까지 탐색하지 않은 정점 중 거리 값이 가장 낮은 정점"을 뽑는 이유는 
   더 이상 그 정점의 거리 값을 더 낮은 값으로 갱신할 일이 없기 때문이다.
   즉, 현재 보고 있는 정점이 v이고, v를 탐색했을 때 이미 탐색했던 정점 u의 거리 값을 갱신하려면 v의 거리 값이 u보다 낮아야 되는데
       (모든 간선의 가중치가 0이상 이므로)
   그렇게 되면, v가 u보다 먼저 탐색되었을 것이므로 모순을 띈다.
   만약, 다익스트라 알고리즘에서 음수 가중치가 있으면 이 특징이 깨져서 다익스트라 알고리즘이 통하지 않는다.
   
11. 동적계획법에 대해 설명하라.
-> 모든 방법을 일일이 검토하여 최적의 해를 찾아내는 방식의 알고리즘
   변수 간 점화식을 만들 수 있는지 체크하여 메모이제이션 기법을 사용하여 문제를 해결하는 방법론
   구현 방식으론 Bottom-up(반복문 활용), Top-Down(재귀 활용)

12. 에라토스테네스의 체 알고리즘에 대해 설명하라.
-> 다수의 자연수에 대하여 소수 여부를 판별할 때 사용하는 전형적인 알고리즘 동작과정
동작과정
-> 2부터 N까지의 모든 자연수를 나열한다.
-> 남은 수 중에서 아직 처리하지 않은 가장 작은 수를 I를 찾는다.
-> 남은 수 중에서 I의 배수를 모두 제거한다.
-> 더 이상 반복할 수 없을 때까지 2번과 3번의 과정을 반복한다.
시간복잡도 O(NloglogN)

13. 소수판별 알고리즘에 대해 설명하고, 성능적으로 향상되게 구현하라.
-> 소수(Prime Number) : 1보다 큰 자연수 중에서 1과 자기자신을 제외한 자연수로는 나누어 떨어지지 않는 자연수
-> ex)
    for (int i = 2; i<=N;i++){
        if N%i == 0{
            return false; //소수 아님
        }
    }
    return true; // 소수
-> ex)
    for (int i = 2; i<=sqrt(N);i++){
        if N%i == 0{
            return false; //소수 아님
        }
    }
    return true; // 소수
-> 성능향상 버전 성능 분석
    -> 모든 약수가 가운데 약수를 기준으로 곱셈 연산에 대해 대칭을 이루는 것을 알 수 있다. 
    -> 따라서 특정한 자연수의 모든 약수를 찾을 때, 가운데 약수(제곱근)까지만 확인하면 된다.
    
14. 크루스칼 알고리즘에 대해 설명하라.
-> 가장 적은 비용으로 모든 노드를 연결하기 위해 사용하는 알고리즘
   즉, 최소 비용 신장 트리(무방향성)를 만들기 위한 대표적인 알고리즘
       그리디 알고리즘으로 분류
-> 신장 트리
    -> 그래프에서 모든 노드를 포함하며 사이클이 존재하지 않는 부분 그래프
    -> 모든 노드가 포함되어 서로 연결되면서 사이클이 존재하지 않는다는 조건은 트리의 조건이기도 하다.
    -> 최소한의 비용으로 구성되는 신장트리를 찾아야 할 때, 크루스칼 알고리즘을 이용하여 구현한다.
동작과정
-> 간선(엣지) 데이터를 비용에 따라 오름차순으로 정렬한다.
-> 간선을 하나씩 확인하며 현재의 간선이 사이클을 발생시키는지 확인한다.
    -> 사이클이 발생하지 않는 경우, 최소신장트리에 포함시킨다.
    -> 사이클이 발생하는 경우, 최소신장트리에 포함시키지 않는다.
-> 모든 간선에 대하여 2번의 과정을 반복한다.
성능분석
-> 간선의 지수가 E개 일때, O(ElogE)의 시간복잡도를 가진다.
   크루스칼 알고리즘에서 가장 많은 시간을 요구하는 곳은 간선을 정렬하는 부분이다.
   
15. 플로이드 워셜 알고리즘에 대해 설명하라.
-> 모든 노드에서 다른 모든 노드까지의 최단 경로를 모두 계산한다.
   다익스트라 알고리즘과 마찬가지로 단계별로 거쳐가는 노드를 기준으로 알고리즘을 수행한다.
   다만, 매단계마다 방문하지 않은 노드 중 최단거리를 찾는 과정이 필요하지 않다.
   2차원 테이블에 최단거리 정보를 저장한다.
   동적계획법(DP유형)에 해당된다.(점화식 : graph[a][b] = *min_element(graph[a][b],graph[a][k] + grapg[k][b]);)
   노드의 개수, 간선의 개수가 적을 때 사용해야 효율적인 알고리즘이다.
   간단히 말하자면, 매번 돌아가는게 빠른가? 그냥 가는게 빠른가를 계산하여 효율적인 것을 택하는 알고리즘.
동작과정
-> 각 단계마다, 특정한 노드 k를 거쳐가는 경우를 확인한다.
   a에서 b로가는 최단거리보다 a에서 k로 거쳐 b로가는 거리가 더 짧은지 검사하여 테이블을 갱신
   -> 그래프 준비 및 최단거리 테이블 초기화
   -> 1번 노드를 거쳐가는 경우를 고려하여 테이블 갱신
   -> 2번 노드를 거쳐가는 경우를 고려하여 테이블 갱신
   -> 2,3번 반복
   
16. 위상정렬에 대해 설명하라.
-> 사이클이 없는 방향 그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열한 것.
큐를 이용하는 위상 정렬 알고리즘의 동작과정
-> 진입차수(Indegree)가 0인 모든 노드를 큐에 넣는다.
-> 큐가 빌때까지 다음의 과정을 반복한다.
    -> 큐에서 원소를 꺼내 해당 노드에서 나가는 간선을 그래프에서 제거한다.
    -> 새롭게 진입차수가 0이된 노드를 큐에 넣는다.
-> 결과적으로 각 노드가 큐에 들어온 순서가 위상정렬을 수행한 결과와 같다.
    -> 진입차수(Indegree): 특정한 노드로 들어오는 간선의 개수
    -> 진출차수(Outdegree) : 특정한 노드에서 나가는 간선의 개수
특징
-> 위상 정렬은 DAG에 대해서만 수행할 수 있다.(DAG : 순환하지 않는 방향 그래프)
-> 위상 정렬에는 여러 가지 답이 존재할 수 있다.(한 단계에서 큐에 새롭게 들어가는 원소가 2개 이상인 경우)
-> 모든 원소를 방문하기 전에 큐가 빈다면 사이클이 존재한다고 판단 가능(사이클에 포함된 원소중 어떠한 것도 큐에 들어갈 수 없다.)
-> 스택을 이용한 DFS를 이용하여 위상정렬을 수행 할 수도 있다.
성능분석
-> 위상정렬을 위해 차례대로 모든 노드를 확인하며 각 노드에서 나가는 간선을 차례대로 제거해야 한다.
시간복잡도 O(V+E)

17. 벨만-포드 알고리즘에 대해 설명하라.
-> 특정한 노드에서 출발하여 다른 모든 노드로 가는 최단경로를 계산하는 알고리즘
   벨만-포드 알고리즘은 음의 간선이 있을 때도 정상 동작
   음의 순환이 있는 경우에는 최단 거리를 찾지 못함(음수 간선 순환 감지 가능)
-> 다익스트라와의 차이점
    -> 매 반복마다 모든 간선을 확인한다는 것
    -> 다익스트라는 방문하지 않는 노드 중에서 최단 거리가 가장 가까운 노드만을 방문했다.
동작과정
-> 시작 노드에 대해서 거리를 0으로 초기화, 나머지 노드는 거리를 무한으로 설정
-> 정점 수 (n-1)만큼 다음 과정을 반복한다.
-> 매 반복마다 모든 간선을 확인
-> 현재 간선을 거쳐서 다른 노드로 이동하는 거리가 짧은 경우, 거리 정보를 갱신
-> n-1번 반복 이후, n번째 반복에서도 거리 값이 갱신된다면 음수 순환이 존재하는 것으로 판단이 가능.

18. 프림 알고리즘은 무엇인지 설명하라.
-> 가중치가 있는 연결된 무방향 그래프의 모든 꼭짓점을 포함하면서 각 변의 비용의 합이 최소가 되도록 하는 알고리즘 
   최소 스패닝 트리(MST)를 찾는 알고리즘이다.
</pre>
